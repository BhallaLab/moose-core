24 June 2007.
Updated 01 June 2008.
Updated 08 July 2008.
Updated 11 July 2008.

All objects (elements) in MOOSE are uniquely identified by an Id. This document
explains how Ids are managed across nodes in a simulation.
...................................................................
Overview
- There is a unique id for every object in a simulation.
- Ids contain an index. All entries in an array element are on the same Id,
	identified by this index.
- On any node, one can do all API calls on an element by referring to its Id.
	(This is still a design goal.)

...................................................................

Kinds of Ids
	- System: 
		- root id is 0. Parent id for everything else.
		- shell id is 1. Manages all system calls.
		- postmaster id is 2. On serial simulations, this is just a
			neutral. Otherwise it is an arrayElement of postmasters
	- Locals: Regular Elements found on the local node.
	- Globals: Elements that have an identical instance present on
		all nodes. Readonly.
	- Scratch: Regular Elements found on local node, but that have not
		yet been reported to the master node. These are updated
		as soon as they are used across nodes, or in a batch when
		the scratch Id range is used up.
	- Proxy: Minimal proxy Elements standing in for a regular Element
		located on some other node. Used for parallel message passing.

...................................................................
Id ranges

0: Root id: This is a global. Every node has an instance of the root.
1: Shell id: This is a global. Every node has an instance of the shell.
	Returned by the static function Id::shellId();
2: Postmaster id: This is a global array element, except when it is a
	serial simulation, in which case this is a neutral.
	In parallel simulations the index looks up the specified node.
	There is a dummy entry for the current node, should not be used.
	Returned by the static function Id::postId( unsigned int node );

[3..IdManager::numScratch-1]: Node-local Ids. Only known to local node.
3 to IdManager::numScratch-1, currently 1000. 
	These are generated by the scratchId() call. 
	This range is private ids that can be assigned without asking
	the master node. If the range is filled, then the whole lot are 
	regularized in one go, and the range is available again.
	If on the master node, we don't have a special scratch space and the
	ids are assigned in the usual way.
[numScratch..]: Proper Ids, registered on master, unique across all nodes.
	Used when the Ids from slave nodes are regularized.


IdManager provides two functions to generate new ids:
	unsigned int scratchId(): Called on all nodes.
	unsigned int childId( unsigned int parent ): Called only on master.
	It internally manages the function regularizeScratch().

...................................................................
Fields:
	unsigned int id_; // Unique identifier for Element*
	unsigned int index_; // Index of array entry within Element
				// This can take the following values:
				// 0..numEntries - 1: proper indices.
				// AnyIndex: Entire array.
				// BadIndex: Invalid entry.

The most commonly used access functions on Id are:

Id Id(): returns the root id, also the zero id.
Id Id( const string& path ) // Returns the id for a path.
Eref eref() // Returns the Eref ( Element* plus eIndex ) of element.
Element* Id() // Returns the element pointed to by an id. Note that much
	// cleverness happens here if the element is off-node.
bool Id::bad() // reports if the id is a bad one.
bool setElement( Element* e ) // Assigns the Element pointer e to the id.

...................................................................
Single-node implementation:

There is a single, statically defined IdManager, accessed through Id.
	This has a vector of all Element*. 
	The Id::id_ is an index into this vector.
	New Elements are pushed back into this vector.
	Currently, we can also reuse discarded Ids.

...................................................................
Multi-node implementation:
- Master node:
	Similar to single node.
	This has a vector of all Element*.
	Element* points to one of:
		Actual Element on master node.
		Postmaster for remote node on which object is located
		Proxy for Element.

- Slave node:
	For now this too has a vector of all Element*.
	Many of these will be in the scratch range, which is node-local.
	Element* points to one one of:
		- local Element
		- postmaster for remote node
		- proxy for remote Element
		- UNKNOWN_NODE.

...................................................................

Rules on validity of these ids. Unless specifically noted for master or slave
node, these rules apply across all nodes.
        - The master node is authoritative and up-to-date.
                All ids on the master node either point to the local object
                or to the relevant postmaster.
        - Ids point to the elements directly if the elements are local.
		All elements are local on a single-node simulation.
	- Global objects are objects instantiated identically on every node.
		They share the same id.
		The id points to the local instance.
		They are read-only once globalized.
        - Off-node ids point to the postmaster of the node on which the
		object resides, unless it is an unknown node. 
        - The master node never has 'UNKNOWN_NODE' elements.
        - Ids on slave nodes may point to an 'UNKNOWN_NODE' element if the
		node is not known. Typically happens when there are gaps
		in the id table of slave nodes, because intervening ids
		may have been assigned to objects on other nodes. 
	- Slave node ids are authoritative for local objects and for
		any object connected by a message.
        - Slave node message targets must never be on UNKNOWN_NODE. Should
		a target initially be unknown, we must update the id
		table by asking the master node.
		- When the id table is updated, we fill up all the unknowns,
		not just the one we needed.
		- If the object moves to a different node the slave node's
		id list must be updated.
	- Even if a slave node id claims to be on a known node, the system
		must be prepared to handle the case that this has changed
		and the local node is out of date.
        - Any deleted element entry must be set to zero. It may be reused.
		- This does not need to instantly propagate to the master node,
			because we allow it to refer to the appropriate
			postmaster to check.
        - Objects can be moved between nodes. Even though initially the
		ids may have been partitioned into blocks, no function may 
		rely on this partitioning to find the id.
                - The master node must be updated if objects move between nodes.

...................................................................
Implementation rules:
- Arrays of elements use a single id for the ArrayElement; the index is
	separate. If the array is distributed between nodes then we use
	a special variant called DistributedArrayElement which has its own
	little map of which node to go to for each index.


