24 June 2007.

All objects (elements) in MOOSE are uniquely identified by an id. This id is
independent of the node on which the element resides. Here we define the
implementation of the id.

...................................................................
Each node has a vector of Element*. The id is the index of this vector.
This elementList is a private member of the IdManager. The IdManager
itself is accessed through a static function to ensure correctly
sequenced initialization:

static IdManager& Id::manager();

The most commonly used access functions on Id are:

Id Id(): returns the root id, also the zero id.
Id Id( const string& path ) // Returns the id for a path.
Element* Id() // Returns the element pointed to by an id. Note that much
	// cleverness happens here if the element is off-node.
bool Id::bad() // reports if the id is a bad one.
bool setElement( Element* e ) // Assigns the Element pointer e to the id.


...................................................................
The elementList vector is subdivided into sections:

Pre-defined entries:
0: root
1: shell

Scratch space (only present on slave nodes)
2 to BLOCK_SIZE, currently 1000. These are generated by the scratchId()
	call. This range is private ids that can be assigned without asking
	the master node. If the range is filled, then the whole lot are 
	regularized in one go, and the range is available again.
	If on the master node, we don't have a special scratch space and the
	ids are assigned in the usual way.

Assigned ids:
These are assigned by the master shell whenever it creates an object,
on any node. They are also generated whenever scratch ids are regularized.

...................................................................

Rules on validity of these ids. Unless specifically noted for master or slave
node, these rules apply across all nodes.
        - The master node is authoritative and up-to-date.
                All ids on the master node either point to the local object
                or to the relevant postmaster.
        - Ids point to the elements directly if the elements are local.
		All elements are local on a single-node simulation.
	- Global objects are objects instantiated identically on every node.
		They share the same id.
		The id points to the local instance.
        - Off-node ids point to the postmaster of the node on which the
		object resides, unless it is an unknown node. 
        - The master node never has 'UNKNOWN_NODE' elements.
        - Ids on slave nodes may point to an 'UNKNOWN_NODE' element if the
		node is not known. Typically happens when there are gaps
		in the id table of slave nodes, because intervening ids
		may have been assigned to objects on other nodes. 
	- Slave node ids are authoritative for local objects and for
		any object connected by a message.
        - Slave node message targets must never be on UNKNOWN_NODE. Should
		a target initially be unknown, we must update the id
		table by asking the master node.
		- When the id table is updated, we fill up all the unknowns,
		not just the one we needed.
		- If the object moves to a different node the slave node's
		id list must be updated.
	- Even if a slave node id claims to be on a known node, the system
		must be prepared to handle the case that this has changed
		and the local node is out of date.
        - Any deleted element entry must be set to zero. It may be reused.
		- This does not need to instantly propagate to the master node,
			because we allow it to refer to the appropriate
			postmaster to check.
        - Objects can be moved between nodes. Even though initially the
		ids may have been partitioned into blocks, no function may 
		rely on this partitioning to find the id.
                - The master node must be updated if objects move between nodes.

...................................................................
Implementation rules:
- Arrays of elements use a single id for the ArrayElement; the index is
	separate. If the array is distributed between nodes then we use
	a special variant called DistributedArrayElement which has its own
	little map of which node to go to for each index.


