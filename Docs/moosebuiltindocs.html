<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Documentation for all MOOSE classes and functions</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="Documentation for all MOOSE classes and functions"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-10-04 20:12:08 IST"/>
<meta name="author" content="Automatically extracted on 2012-10-04T20:11:55.291611"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Documentation for all MOOSE classes and functions</h1>

<p><i>As visible in Python module</i>
</p>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 MOOSE Classes</a>
<ul>
<li><a href="#sec-1-1">1.1 Annotator</a></li>
<li><a href="#sec-1-2">1.2 Arith</a></li>
<li><a href="#sec-1-3">1.3 Boundary</a></li>
<li><a href="#sec-1-4">1.4 BufPool</a></li>
<li><a href="#sec-1-5">1.5 CaConc</a></li>
<li><a href="#sec-1-6">1.6 ChanBase</a></li>
<li><a href="#sec-1-7">1.7 ChemMesh</a></li>
<li><a href="#sec-1-8">1.8 Cinfo</a></li>
<li><a href="#sec-1-9">1.9 Clock</a></li>
<li><a href="#sec-1-10">1.10 Compartment</a></li>
<li><a href="#sec-1-11">1.11 CplxEnzBase</a></li>
<li><a href="#sec-1-12">1.12 CubeMesh</a></li>
<li><a href="#sec-1-13">1.13 CylMesh</a></li>
<li><a href="#sec-1-14">1.14 CylPanel</a></li>
<li><a href="#sec-1-15">1.15 DiagonalMsg</a></li>
<li><a href="#sec-1-16">1.16 DiffAmp</a></li>
<li><a href="#sec-1-17">1.17 DiskPanel</a></li>
<li><a href="#sec-1-18">1.18 Enz</a></li>
<li><a href="#sec-1-19">1.19 EnzBase</a></li>
<li><a href="#sec-1-20">1.20 Finfo</a></li>
<li><a href="#sec-1-21">1.21 FuncPool</a></li>
<li><a href="#sec-1-22">1.22 GHK</a></li>
<li><a href="#sec-1-23">1.23 Geometry</a></li>
<li><a href="#sec-1-24">1.24 Group</a></li>
<li><a href="#sec-1-25">1.25 GslIntegrator</a></li>
<li><a href="#sec-1-26">1.26 GssaStoich</a></li>
<li><a href="#sec-1-27">1.27 HDF5DataWriter</a></li>
<li><a href="#sec-1-28">1.28 HDF5WriterBase</a></li>
<li><a href="#sec-1-29">1.29 HHChannel</a></li>
<li><a href="#sec-1-30">1.30 HHChannel2D</a></li>
<li><a href="#sec-1-31">1.31 HHGate</a></li>
<li><a href="#sec-1-32">1.32 HHGate2D</a></li>
<li><a href="#sec-1-33">1.33 HSolve</a></li>
<li><a href="#sec-1-34">1.34 HemispherePanel</a></li>
<li><a href="#sec-1-35">1.35 IntFire</a></li>
<li><a href="#sec-1-36">1.36 Interpol2D</a></li>
<li><a href="#sec-1-37">1.37 IzhikevichNrn</a></li>
<li><a href="#sec-1-38">1.38 LeakyIaF</a></li>
<li><a href="#sec-1-39">1.39 MMenz</a></li>
<li><a href="#sec-1-40">1.40 MarkovChannel</a></li>
<li><a href="#sec-1-41">1.41 MarkovGslSolver</a></li>
<li><a href="#sec-1-42">1.42 MarkovRateTable</a></li>
<li><a href="#sec-1-43">1.43 MarkovSolver</a></li>
<li><a href="#sec-1-44">1.44 MarkovSolverBase</a></li>
<li><a href="#sec-1-45">1.45 MathFunc</a></li>
<li><a href="#sec-1-46">1.46 Mdouble</a></li>
<li><a href="#sec-1-47">1.47 MeshEntry</a></li>
<li><a href="#sec-1-48">1.48 MgBlock</a></li>
<li><a href="#sec-1-49">1.49 Msg</a></li>
<li><a href="#sec-1-50">1.50 Mstring</a></li>
<li><a href="#sec-1-51">1.51 NMDAChan</a></li>
<li><a href="#sec-1-52">1.52 Nernst</a></li>
<li><a href="#sec-1-53">1.53 NeuroMesh</a></li>
<li><a href="#sec-1-54">1.54 Neuron</a></li>
<li><a href="#sec-1-55">1.55 Neutral</a></li>
<li><a href="#sec-1-56">1.56 OneToAllMsg</a></li>
<li><a href="#sec-1-57">1.57 OneToOneMsg</a></li>
<li><a href="#sec-1-58">1.58 PIDController</a></li>
<li><a href="#sec-1-59">1.59 Panel</a></li>
<li><a href="#sec-1-60">1.60 Pool</a></li>
<li><a href="#sec-1-61">1.61 PoolBase</a></li>
<li><a href="#sec-1-62">1.62 Port</a></li>
<li><a href="#sec-1-63">1.63 PulseGen</a></li>
<li><a href="#sec-1-64">1.64 RC</a></li>
<li><a href="#sec-1-65">1.65 Reac</a></li>
<li><a href="#sec-1-66">1.66 ReacBase</a></li>
<li><a href="#sec-1-67">1.67 RectPanel</a></li>
<li><a href="#sec-1-68">1.68 ReduceMsg</a></li>
<li><a href="#sec-1-69">1.69 Shell</a></li>
<li><a href="#sec-1-70">1.70 SimManager</a></li>
<li><a href="#sec-1-71">1.71 SingleMsg</a></li>
<li><a href="#sec-1-72">1.72 SparseMsg</a></li>
<li><a href="#sec-1-73">1.73 Species</a></li>
<li><a href="#sec-1-74">1.74 SpherePanel</a></li>
<li><a href="#sec-1-75">1.75 SpikeGen</a></li>
<li><a href="#sec-1-76">1.76 Stats</a></li>
<li><a href="#sec-1-77">1.77 StimulusTable</a></li>
<li><a href="#sec-1-78">1.78 Stoich</a></li>
<li><a href="#sec-1-79">1.79 SumFunc</a></li>
<li><a href="#sec-1-80">1.80 Surface</a></li>
<li><a href="#sec-1-81">1.81 SymCompartment</a></li>
<li><a href="#sec-1-82">1.82 SynBase</a></li>
<li><a href="#sec-1-83">1.83 SynChan</a></li>
<li><a href="#sec-1-84">1.84 SynChanBase</a></li>
<li><a href="#sec-1-85">1.85 Synapse</a></li>
<li><a href="#sec-1-86">1.86 Table</a></li>
<li><a href="#sec-1-87">1.87 TableBase</a></li>
<li><a href="#sec-1-88">1.88 TableEntry</a></li>
<li><a href="#sec-1-89">1.89 Tick</a></li>
<li><a href="#sec-1-90">1.90 TriPanel</a></li>
<li><a href="#sec-1-91">1.91 VectorTable</a></li>
<li><a href="#sec-1-92">1.92 ZombieBufPool</a></li>
<li><a href="#sec-1-93">1.93 ZombieCaConc</a></li>
<li><a href="#sec-1-94">1.94 ZombieCompartment</a></li>
<li><a href="#sec-1-95">1.95 ZombieEnz</a></li>
<li><a href="#sec-1-96">1.96 ZombieFuncPool</a></li>
<li><a href="#sec-1-97">1.97 ZombieHHChannel</a></li>
<li><a href="#sec-1-98">1.98 ZombieMMenz</a></li>
<li><a href="#sec-1-99">1.99 ZombiePool</a></li>
<li><a href="#sec-1-100">1.100 ZombieReac</a></li>
<li><a href="#sec-1-101">1.101 ZombieSumFunc</a></li>
<li><a href="#sec-1-102">1.102 testSched</a></li>
</ul>
</li>
<li><a href="#sec-2">2 MOOSE Functions</a>
<ul>
<li><a href="#sec-2-1">2.1 ce</a></li>
<li><a href="#sec-2-2">2.2 connect</a></li>
<li><a href="#sec-2-3">2.3 copy</a></li>
<li><a href="#sec-2-4">2.4 delete</a></li>
<li><a href="#sec-2-5">2.5 element</a></li>
<li><a href="#sec-2-6">2.6 exists</a></li>
<li><a href="#sec-2-7">2.7 getCwe</a></li>
<li><a href="#sec-2-8">2.8 getField</a></li>
<li><a href="#sec-2-9">2.9 getFieldDict</a></li>
<li><a href="#sec-2-10">2.10 getFieldNames</a></li>
<li><a href="#sec-2-11">2.11 isRunning</a></li>
<li><a href="#sec-2-12">2.12 loadModel</a></li>
<li><a href="#sec-2-13">2.13 move</a></li>
<li><a href="#sec-2-14">2.14 quit</a></li>
<li><a href="#sec-2-15">2.15 reinit</a></li>
<li><a href="#sec-2-16">2.16 saveModel</a></li>
<li><a href="#sec-2-17">2.17 seed</a></li>
<li><a href="#sec-2-18">2.18 setClock</a></li>
<li><a href="#sec-2-19">2.19 setCwe</a></li>
<li><a href="#sec-2-20">2.20 start</a></li>
<li><a href="#sec-2-21">2.21 stop</a></li>
<li><a href="#sec-2-22">2.22 useClock</a></li>
<li><a href="#sec-2-23">2.23 wildcardFind</a></li>
<li><a href="#sec-2-24">2.24 writeSBML</a></li>
<li><a href="#sec-2-25">2.25 doc</a></li>
<li><a href="#sec-2-26">2.26 getfielddoc</a></li>
<li><a href="#sec-2-27">2.27 getmoosedoc</a></li>
<li><a href="#sec-2-28">2.28 le</a></li>
<li><a href="#sec-2-29">2.29 listmsg</a></li>
<li><a href="#sec-2-30">2.30 pwe</a></li>
<li><a href="#sec-2-31">2.31 showfield</a></li>
<li><a href="#sec-2-32">2.32 showfields</a></li>
<li><a href="#sec-2-33">2.33 showmsg</a></li>
<li><a href="#sec-2-34">2.34 syncDataHandler</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> MOOSE Classes</h2>
<div class="outline-text-2" id="text-1">




</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Annotator</h3>
<div class="outline-text-3" id="text-1-1">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>x:       <i>double</i></dt><dd>
<p>
       x field. Typically display coordinate x
</p></dd>
<dt>y:       <i>double</i></dt><dd>
<p>
       y field. Typically display coordinate y
</p></dd>
<dt>z:       <i>double</i></dt><dd>
<p>
       z field. Typically display coordinate z
</p></dd>
<dt>notes:   <i>string</i></dt><dd>
<p>
       A string to hold some text notes about parent object
</p></dd>
<dt>color:   <i>string</i></dt><dd>
<p>
       A string to hold a text string specifying display color.Can be a regular English color name, or an rgb code rrrgggbbb
</p></dd>
<dt>textColor:       <i>string</i></dt><dd>
<p>
       A string to hold a text string specifying color for text labelthat might be on the display for this object.Can be a regular English color name, or an rgb code rrrgggbbb
</p></dd>
<dt>icon:    <i>string</i></dt><dd>
<p>
       A string to specify icon to use for display
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Arith</h3>
<div class="outline-text-3" id="text-1-2">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>function:        <i>string</i></dt><dd>
<p>
       Arithmetic function to perform on inputs.
</p></dd>
<dt>outputValue:     <i>double</i></dt><dd>
<p>
       Value of output as computed last timestep.
</p></dd>
<dt>arg1Value:       <i>double</i></dt><dd>
<p>
       Value of arg1 as computed last timestep.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Sends out the computed value
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>arg1:    <i>double</i></dt><dd>
<p>
       Handles argument 1. This just assigns it
</p></dd>
<dt>arg2:    <i>double</i></dt><dd>
<p>
       Handles argument 2. This just assigns it
</p></dd>
<dt>arg3:    <i>double</i></dt><dd>
<p>
       Handles argument 3. This sums in each input, and clears each clock tick.
</p></dd>
<dt>arg1x2:  <i>double,double</i></dt><dd>
<p>
       Store the product of the two arguments in output_
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>anyValue:        <i>unsigned int,double</i></dt><dd>
<p>
       Value of any of the internal fields, output, arg1, arg2, arg3,as specified by the index argument from 0 to 3.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Boundary</h3>
<div class="outline-text-3" id="text-1-3">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>reflectivity:    <i>double</i></dt><dd>
<p>
       What happens to a molecule hitting it: bounces, absorbed, diffused?
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toAdjacent:      <i>void</i></dt><dd>
<p>
       Dummy message going to adjacent compartment.
</p></dd>
<dt>toInside:        <i>void</i></dt><dd>
<p>
       Dummy message going to surrounded compartment.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>adjacent:        <i>void</i></dt><dd>
<p>
       Dummy message coming from adjacent compartment to current oneImplies that compts are peers: do not surround each other
</p></dd>
<dt>outside: <i>void</i></dt><dd>
<p>
       Dummy message coming from surrounding compartment to this one.Implies that the originating compartment surrounds this one
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> BufPool</h3>
<div class="outline-text-3" id="text-1-4">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p></dd>
<dt>increment:       <i>double</i></dt><dd>
<p>
       Increments mol numbers by specified amount. Can be +ve or -ve
</p></dd>
<dt>decrement:       <i>double</i></dt><dd>
<p>
       Decrements mol numbers by specified amount. Can be +ve or -ve
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>reac:    <i>void</i></dt><dd>
<p>
       Connects to reaction
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p></dd>
<dt>species: <i>void</i></dt><dd>
<p>
       Shared message for connecting to species objects
</p></dd>
<dt>mesh:    <i>void</i></dt><dd>
<p>
       Shared message for dealing with mesh operations
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> CaConc</h3>
<div class="outline-text-3" id="text-1-5">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Ca:      <i>double</i></dt><dd>
<p>
       Calcium concentration.
</p></dd>
<dt>CaBasal: <i>double</i></dt><dd>
<p>
       Basal Calcium concentration.
</p></dd>
<dt>Ca<sub>base</sub>: <i>double</i></dt><dd>
<p>
       Basal Calcium concentration, synonym for CaBasal
</p></dd>
<dt>tau:     <i>double</i></dt><dd>
<p>
       Settling time for Ca concentration
</p></dd>
<dt>B:       <i>double</i></dt><dd>
<p>
       Volume scaling factor
</p></dd>
<dt>thick:   <i>double</i></dt><dd>
<p>
       Thickness of Ca shell.
</p></dd>
<dt>ceiling: <i>double</i></dt><dd>
<p>
       Ceiling value for Ca concentration. If Ca &gt; ceiling, Ca = ceiling. If ceiling &lt;= 0.0, there is no upper limit on Ca concentration value.
</p></dd>
<dt>floor:   <i>double</i></dt><dd>
<p>
       Floor value for Ca concentration. If Ca &lt; floor, Ca = floor
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>concOut: <i>double</i></dt><dd>
<p>
       Concentration of Ca in pool
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>current: <i>double</i></dt><dd>
<p>
       Calcium Ion current, due to be converted to conc.
</p></dd>
<dt>currentFraction: <i>double,double</i></dt><dd>
<p>
       Fraction of total Ion current, that is carried by Ca2+.
</p></dd>
<dt>increase:        <i>double</i></dt><dd>
<p>
       Any input current that increases the concentration.
</p></dd>
<dt>decrease:        <i>double</i></dt><dd>
<p>
       Any input current that decreases the concentration.
</p></dd>
<dt>basal:   <i>double</i></dt><dd>
<p>
       Synonym for assignment of basal conc.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message to receive Process message from scheduler
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> ChanBase</h3>
<div class="outline-text-3" id="text-1-6">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message to couple channel to compartment. The first entry is a MsgSrc to send Gk and Ek to the compartment The second entry is a MsgDest for Vm from the compartment.
</p></dd>
<dt>ghk:     <i>void</i></dt><dd>
<p>
       Message to Goldman-Hodgkin-Katz object
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> ChemMesh</h3>
<div class="outline-text-3" id="text-1-7">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of entire chemical domain.Assigning this assumes that the geometry is that of the default mesh, which may not be what you want. If so, usea more specific mesh assignment function.
</p></dd>
<dt>numDimensions:   <i>unsigned int</i></dt><dd>
<p>
       Number of spatial dimensions of this compartment. Usually 3 or 2
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Defines how meshEntries communicate between nodes.Args: oldVol, volListOfAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#]This message is meant to go to the SimManager and Stoich.
</p></dd>
<dt>meshStats:       <i>unsigned int,vector&lt;double&gt;</i></dt><dd>
<p>
       Basic statistics for mesh: Total # of entries, and a vector ofunique volumes of voxels
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>buildDefaultMesh:        <i>double,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh derived class to build a default mesh with thespecified size and number of meshEntries.
</p></dd>
<dt>handleRequestMeshStats:  <i>void</i></dt><dd>
<p>
       Handles request from SimManager for mesh stats
</p></dd>
<dt>handleNodeInfo:  <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh how many nodes and threads per node it is allowed to use. Triggers a return meshSplit message.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>nodeMeshing:     <i>void</i></dt><dd>
<p>
       Connects to SimManager to coordinate meshing with paralleldecomposition and with the Stoich
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> Cinfo</h3>
<div class="outline-text-3" id="text-1-8">

<p>   Author:              Upi Bhalla
</p>
<p>   
   Description:         Class information object.
</p>
<p>   
   Name:                Cinfo
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>docs:    <i>string</i></dt><dd>
<p>
       Documentation
</p></dd>
<dt>baseClass:       <i>string</i></dt><dd>
<p>
       Name of base class
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> Clock</h3>
<div class="outline-text-3" id="text-1-9">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>runTime: <i>double</i></dt><dd>
<p>
       Duration to run the simulation
</p></dd>
<dt>currentTime:     <i>double</i></dt><dd>
<p>
       Current simulation time
</p></dd>
<dt>nsteps:  <i>unsigned int</i></dt><dd>
<p>
       Number of steps to advance the simulation, in units of the smallest timestep on the clock ticks
</p></dd>
<dt>numTicks:        <i>unsigned int</i></dt><dd>
<p>
       Number of clock ticks
</p></dd>
<dt>currentStep:     <i>unsigned int</i></dt><dd>
<p>
       Current simulation step
</p></dd>
<dt>dts:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Utility function returning the dt (timestep) of all ticks.
</p></dd>
<dt>isRunning:       <i>bool</i></dt><dd>
<p>
       Utility function to report if simulation is in progress.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>childTick:       <i>void</i></dt><dd>
<p>
       Parent of Tick element
</p></dd>
<dt>finished:        <i>void</i></dt><dd>
<p>
       Signal for completion of run
</p></dd>
<dt>ack:     <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Acknowledgement signal for receipt/completion of function.Goes back to Shell on master node
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>start:   <i>double</i></dt><dd>
<p>
       Sets off the simulation for the specified duration
</p></dd>
<dt>step:    <i>unsigned int</i></dt><dd>
<p>
       Sets off the simulation for the specified # of steps
</p></dd>
<dt>stop:    <i>void</i></dt><dd>
<p>
       Halts the simulation, with option to restart seamlessly
</p></dd>
<dt>setupTick:       <i>unsigned int,double</i></dt><dd>
<p>
       Sets up a specific clock tick: args tick#, dt
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Zeroes out all ticks, starts at t = 0
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>clockControl:    <i>void</i></dt><dd>
<p>
       Controls all scheduling aspects of Clock, usually from Shell
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> Compartment</h3>
<div class="outline-text-3" id="text-1-10">

<p>   Author:              Upi Bhalla
</p>
<p>   
   Description:         Compartment object, for branching neuron models.
</p>
<p>   
   Name:                Compartment
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       membrane potential
</p></dd>
<dt>Cm:      <i>double</i></dt><dd>
<p>
       Membrane capacitance
</p></dd>
<dt>Em:      <i>double</i></dt><dd>
<p>
       Resting membrane potential
</p></dd>
<dt>Im:      <i>double</i></dt><dd>
<p>
       Current going through membrane
</p></dd>
<dt>inject:  <i>double</i></dt><dd>
<p>
       Current injection to deliver into compartment
</p></dd>
<dt>initVm:  <i>double</i></dt><dd>
<p>
       Initial value for membrane potential
</p></dd>
<dt>Rm:      <i>double</i></dt><dd>
<p>
       Membrane resistance
</p></dd>
<dt>Ra:      <i>double</i></dt><dd>
<p>
       Axial resistance of compartment
</p></dd>
<dt>diameter:        <i>double</i></dt><dd>
<p>
       Diameter of compartment
</p></dd>
<dt>length:  <i>double</i></dt><dd>
<p>
       Length of compartment
</p></dd>
<dt>x0:      <i>double</i></dt><dd>
<p>
       X coordinate of start of compartment
</p></dd>
<dt>y0:      <i>double</i></dt><dd>
<p>
       Y coordinate of start of compartment
</p></dd>
<dt>z0:      <i>double</i></dt><dd>
<p>
       Z coordinate of start of compartment
</p></dd>
<dt>x:       <i>double</i></dt><dd>
<p>
       x coordinate of end of compartment
</p></dd>
<dt>y:       <i>double</i></dt><dd>
<p>
       y coordinate of end of compartment
</p></dd>
<dt>z:       <i>double</i></dt><dd>
<p>
       z coordinate of end of compartment
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment on each timestep
</p></dd>
<dt>axialOut:        <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment to adjacent compartments,on each timestep
</p></dd>
<dt>raxialOut:       <i>double,double</i></dt><dd>
<p>
       Sends out Raxial information on each timestep, fields are Ra and Vm
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>randInject:      <i>double,double</i></dt><dd>
<p>
       Sends a random injection current to the compartment. Must beupdated each timestep.Arguments to randInject are probability and current.
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>cable:   <i>void</i></dt><dd>
<p>
       Message for organizing compartments into groups, calledcables. Doesn't do anything.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles 'process' call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles 'reinit' call
</p></dd>
<dt>initProc:        <i>void</i></dt><dd>
<p>
       Handles Process call for the 'init' phase of the Compartment calculations. These occur as a separate Tick cycle from the regular proc cycle, and should be called before the proc msg.
</p></dd>
<dt>initReinit:      <i>void</i></dt><dd>
<p>
       Handles Reinit call for the 'init' phase of the Compartment calculations.
</p></dd>
<dt>handleChannel:   <i>double,double</i></dt><dd>
<p>
       Handles conductance and Reversal potential arguments from Channel
</p></dd>
<dt>handleRaxial:    <i>double,double</i></dt><dd>
<p>
       Handles Raxial info: arguments are Ra and Vm.
</p></dd>
<dt>handleAxial:     <i>double</i></dt><dd>
<p>
       Handles Axial information. Argument is just Vm.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process messages from the scheduler objects. The Process should be called <span style="text-decoration:underline;">second</span> in each clock tick, after the Init message.The first entry in the shared msg is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt and so on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo. 
</p></dd>
<dt>init:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Init messages from the scheduler objects. Its job is to separate the compartmental calculations from the message passing. It doesn't really need to be shared, as it does not use the reinit part, but the scheduler objects expect this form of message for all scheduled output. The first entry is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt and so on. The second entry is a dummy MsgDest for the Reinit operation. It also uses ProcInfo. 
</p></dd>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message from a compartment to channels. The first entry is a MsgDest for the info coming from the channel. It expects Gk and Ek from the channel as args. The second entry is a MsgSrc sending Vm 
</p></dd>
<dt>axial:   <i>void</i></dt><dd>
<p>
       This is a shared message between asymmetric compartments. axial messages (this kind) connect up to raxial messages (defined below). The soma should use raxial messages to connect to the axial message of all the immediately adjacent dendritic compartments.This puts the (low) somatic resistance in series with these dendrites. Dendrites should then use raxial messages toconnect on to more distal dendrites. In other words, raxial messages should face outward from the soma. The first entry is a MsgSrc sending Vm to the axialFuncof the target compartment. The second entry is a MsgDest for the info coming from the other compt. It expects Ra and Vm from the other compt as args. Note that the message is named after the source type. 
</p></dd>
<dt>raxial:  <i>void</i></dt><dd>
<p>
       This is a raxial shared message between asymmetric compartments. The first entry is a MsgDest for the info coming from the other compt. It expects Vm from the other compt as an arg. The second is a MsgSrc sending Ra and Vm to the raxialFunc of the target compartment. 
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> CplxEnzBase</h3>
<div class="outline-text-3" id="text-1-11">

<p>   Author:              Upi Bhalla
</p>
<p>   
   Description::                Base class for mass-action enzymes in which there is an  explicit pool for the enzyme-substrate complex. It models the reaction: E + S &lt;===&gt; E.S -&mdash;&gt; E + P
</p>
<p>   
   Name:                CplxEnzBase
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p></dd>
<dt>k1:      <i>double</i></dt><dd>
<p>
       Forward reaction from enz + sub to complex
</p></dd>
<dt>k2:      <i>double</i></dt><dd>
<p>
       Reverse reaction from complex to enz + sub
</p></dd>
<dt>k3:      <i>double</i></dt><dd>
<p>
       Forward rate constant from complex to product + enz
</p></dd>
<dt>ratio:   <i>double</i></dt><dd>
<p>
       Ratio of k2/k3
</p></dd>
<dt>concK1:  <i>double</i></dt><dd>
<p>
       K1 expressed in concentration (1/millimolar.sec) units
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toEnz:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toCplx:  <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>cplxDest:        <i>double</i></dt><dd>
<p>
       Handles # of molecules of enz-sub complex
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>sub:     <i>void</i></dt><dd>
<p>
       Connects to substrate molecule
</p></dd>
<dt>prd:     <i>void</i></dt><dd>
<p>
       Connects to product molecule
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p></dd>
<dt>enz:     <i>void</i></dt><dd>
<p>
       Connects to enzyme pool
</p></dd>
<dt>cplx:    <i>void</i></dt><dd>
<p>
       Connects to enz-sub complex pool
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> CubeMesh</h3>
<div class="outline-text-3" id="text-1-12">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of entire chemical domain.Assigning this assumes that the geometry is that of the default mesh, which may not be what you want. If so, usea more specific mesh assignment function.
</p></dd>
<dt>numDimensions:   <i>unsigned int</i></dt><dd>
<p>
       Number of spatial dimensions of this compartment. Usually 3 or 2
</p></dd>
<dt>isToroid:        <i>bool</i></dt><dd>
<p>
       Flag. True when the mesh should be toroidal, that is,when going beyond the right face brings us around to theleft-most mesh entry, and so on. If we have nx, ny, nzentries, this rule means that the coordinate (x, ny, z)will map onto (x, 0, z). Similarly,(-1, y, z) -&gt; (nx-1, y, z)Default is false
</p></dd>
<dt>preserveNumEntries:      <i>bool</i></dt><dd>
<p>
       Flag. When it is true, the numbers nx, ny, nz remainunchanged when x0, x1, y0, y1, z0, z1 are altered. Thusdx, dy, dz would change instead. When it is false, thendx, dy, dz remain the same and nx, ny, nz are altered.Default is true
</p></dd>
<dt>x0:      <i>double</i></dt><dd>
<p>
       X coord of one end
</p></dd>
<dt>y0:      <i>double</i></dt><dd>
<p>
       Y coord of one end
</p></dd>
<dt>z0:      <i>double</i></dt><dd>
<p>
       Z coord of one end
</p></dd>
<dt>x1:      <i>double</i></dt><dd>
<p>
       X coord of other end
</p></dd>
<dt>y1:      <i>double</i></dt><dd>
<p>
       Y coord of other end
</p></dd>
<dt>z1:      <i>double</i></dt><dd>
<p>
       Z coord of other end
</p></dd>
<dt>dx:      <i>double</i></dt><dd>
<p>
       X size for mesh
</p></dd>
<dt>dy:      <i>double</i></dt><dd>
<p>
       Y size for mesh
</p></dd>
<dt>dz:      <i>double</i></dt><dd>
<p>
       Z size for mesh
</p></dd>
<dt>nx:      <i>unsigned int</i></dt><dd>
<p>
       Number of subdivisions in mesh in X
</p></dd>
<dt>ny:      <i>unsigned int</i></dt><dd>
<p>
       Number of subdivisions in mesh in Y
</p></dd>
<dt>nz:      <i>unsigned int</i></dt><dd>
<p>
       Number of subdivisions in mesh in Z
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Set all the coords of the cuboid at once. Order is:x0 y0 z0   x1 y1 z1   dx dy dz
</p></dd>
<dt>meshToSpace:     <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array in which each mesh entry stores spatial (cubic) index
</p></dd>
<dt>spaceToMesh:     <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array in which each space index (obtained by linearizing the xyz coords) specifies which meshIndex is present.In many cases the index will store the EMPTY flag if there isno mesh entry at that spatial location
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Defines how meshEntries communicate between nodes.Args: oldVol, volListOfAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#]This message is meant to go to the SimManager and Stoich.
</p></dd>
<dt>meshStats:       <i>unsigned int,vector&lt;double&gt;</i></dt><dd>
<p>
       Basic statistics for mesh: Total # of entries, and a vector ofunique volumes of voxels
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>buildDefaultMesh:        <i>double,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh derived class to build a default mesh with thespecified size and number of meshEntries.
</p></dd>
<dt>handleRequestMeshStats:  <i>void</i></dt><dd>
<p>
       Handles request from SimManager for mesh stats
</p></dd>
<dt>handleNodeInfo:  <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh how many nodes and threads per node it is allowed to use. Triggers a return meshSplit message.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>nodeMeshing:     <i>void</i></dt><dd>
<p>
       Connects to SimManager to coordinate meshing with paralleldecomposition and with the Stoich
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-13" class="outline-3">
<h3 id="sec-1-13"><span class="section-number-3">1.13</span> CylMesh</h3>
<div class="outline-text-3" id="text-1-13">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of entire chemical domain.Assigning this assumes that the geometry is that of the default mesh, which may not be what you want. If so, usea more specific mesh assignment function.
</p></dd>
<dt>numDimensions:   <i>unsigned int</i></dt><dd>
<p>
       Number of spatial dimensions of this compartment. Usually 3 or 2
</p></dd>
<dt>x0:      <i>double</i></dt><dd>
<p>
       x coord of one end
</p></dd>
<dt>y0:      <i>double</i></dt><dd>
<p>
       y coord of one end
</p></dd>
<dt>z0:      <i>double</i></dt><dd>
<p>
       z coord of one end
</p></dd>
<dt>r0:      <i>double</i></dt><dd>
<p>
       Radius of one end
</p></dd>
<dt>x1:      <i>double</i></dt><dd>
<p>
       x coord of other end
</p></dd>
<dt>y1:      <i>double</i></dt><dd>
<p>
       y coord of other end
</p></dd>
<dt>z1:      <i>double</i></dt><dd>
<p>
       z coord of other end
</p></dd>
<dt>r1:      <i>double</i></dt><dd>
<p>
       Radius of other end
</p></dd>
<dt>lambda:  <i>double</i></dt><dd>
<p>
       Length constant to use for subdivisionsThe system will attempt to subdivide using compartments oflength lambda on average. If the cylinder has different enddiameters r0 and r1, it will scale to smaller lengthsfor the smaller diameter end and vice versa.Once the value is set it will recompute lambda as totLength/numEntries
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coords as a single vector: x0 y0 z0  x1 y1 z1  r0 r1 lambda
</p></dd>
<dt>totLength:       <i>double</i></dt><dd>
<p>
       Total length of cylinder
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Defines how meshEntries communicate between nodes.Args: oldVol, volListOfAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#]This message is meant to go to the SimManager and Stoich.
</p></dd>
<dt>meshStats:       <i>unsigned int,vector&lt;double&gt;</i></dt><dd>
<p>
       Basic statistics for mesh: Total # of entries, and a vector ofunique volumes of voxels
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>buildDefaultMesh:        <i>double,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh derived class to build a default mesh with thespecified size and number of meshEntries.
</p></dd>
<dt>handleRequestMeshStats:  <i>void</i></dt><dd>
<p>
       Handles request from SimManager for mesh stats
</p></dd>
<dt>handleNodeInfo:  <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh how many nodes and threads per node it is allowed to use. Triggers a return meshSplit message.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>nodeMeshing:     <i>void</i></dt><dd>
<p>
       Connects to SimManager to coordinate meshing with paralleldecomposition and with the Stoich
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-14" class="outline-3">
<h3 id="sec-1-14"><span class="section-number-3">1.14</span> CylPanel</h3>
<div class="outline-text-3" id="text-1-14">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-15" class="outline-3">
<h3 id="sec-1-15"><span class="section-number-3">1.15</span> DiagonalMsg</h3>
<div class="outline-text-3" id="text-1-15">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p></dd>
<dt>stride:  <i>int</i></dt><dd>
<p>
       The stride is the increment to the src DataId that gives thedest DataId. It can be positive or negative, but bounds checkingtakes place and it does not wrap around.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-16" class="outline-3">
<h3 id="sec-1-16"><span class="section-number-3">1.16</span> DiffAmp</h3>
<div class="outline-text-3" id="text-1-16">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>gain:    <i>double</i></dt><dd>
<p>
       Gain of the amplifier. The output of the amplifier is the difference between the totals in plus and minus inputs multiplied by the gain. Defaults to 1
</p></dd>
<dt>saturation:      <i>double</i></dt><dd>
<p>
       Saturation is the bound on the output. If output goes beyond the +/-saturation range, it is truncated to the closer of +saturation and -saturation. Defaults to the maximum double precision floating point number representable on the system.
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Output of the amplifier, i.e. gain * (plus - minus).
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>outputOut:       <i>double</i></dt><dd>
<p>
       Current output level.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>gainIn:  <i>double</i></dt><dd>
<p>
       Destination message to control gain dynamically.
</p></dd>
<dt>plusIn:  <i>double</i></dt><dd>
<p>
       Positive input terminal of the amplifier. All the messages connected here are summed up to get total positive input.
</p></dd>
<dt>minusIn: <i>double</i></dt><dd>
<p>
       Negative input terminal of the amplifier. All the messages connected here are summed up to get total positive input.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call, updates internal time stamp.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process messages from the scheduler objects.The first entry in the shared msg is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt and so on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo. 
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-17" class="outline-3">
<h3 id="sec-1-17"><span class="section-number-3">1.17</span> DiskPanel</h3>
<div class="outline-text-3" id="text-1-17">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-18" class="outline-3">
<h3 id="sec-1-18"><span class="section-number-3">1.18</span> Enz</h3>
<div class="outline-text-3" id="text-1-18">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p></dd>
<dt>k1:      <i>double</i></dt><dd>
<p>
       Forward reaction from enz + sub to complex
</p></dd>
<dt>k2:      <i>double</i></dt><dd>
<p>
       Reverse reaction from complex to enz + sub
</p></dd>
<dt>k3:      <i>double</i></dt><dd>
<p>
       Forward rate constant from complex to product + enz
</p></dd>
<dt>ratio:   <i>double</i></dt><dd>
<p>
       Ratio of k2/k3
</p></dd>
<dt>concK1:  <i>double</i></dt><dd>
<p>
       K1 expressed in concentration (1/millimolar.sec) units
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toEnz:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toCplx:  <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>cplxDest:        <i>double</i></dt><dd>
<p>
       Handles # of molecules of enz-sub complex
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>sub:     <i>void</i></dt><dd>
<p>
       Connects to substrate molecule
</p></dd>
<dt>prd:     <i>void</i></dt><dd>
<p>
       Connects to product molecule
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p></dd>
<dt>enz:     <i>void</i></dt><dd>
<p>
       Connects to enzyme pool
</p></dd>
<dt>cplx:    <i>void</i></dt><dd>
<p>
       Connects to enz-sub complex pool
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-19" class="outline-3">
<h3 id="sec-1-19"><span class="section-number-3">1.19</span> EnzBase</h3>
<div class="outline-text-3" id="text-1-19">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>sub:     <i>void</i></dt><dd>
<p>
       Connects to substrate molecule
</p></dd>
<dt>prd:     <i>void</i></dt><dd>
<p>
       Connects to product molecule
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-20" class="outline-3">
<h3 id="sec-1-20"><span class="section-number-3">1.20</span> Finfo</h3>
<div class="outline-text-3" id="text-1-20">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of Finfo
</p></dd>
<dt>docs:    <i>string</i></dt><dd>
<p>
       Documentation for Finfo
</p></dd>
<dt>type:    <i>string</i></dt><dd>
<p>
       RTTI type info for this Finfo
</p></dd>
<dt>src:     <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Subsidiary SrcFinfos. Useful for SharedFinfos
</p></dd>
<dt>dest:    <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Subsidiary DestFinfos. Useful for SharedFinfos
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-21" class="outline-3">
<h3 id="sec-1-21"><span class="section-number-3">1.21</span> FuncPool</h3>
<div class="outline-text-3" id="text-1-21">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p></dd>
<dt>increment:       <i>double</i></dt><dd>
<p>
       Increments mol numbers by specified amount. Can be +ve or -ve
</p></dd>
<dt>decrement:       <i>double</i></dt><dd>
<p>
       Decrements mol numbers by specified amount. Can be +ve or -ve
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Handles input to control value of n_
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>reac:    <i>void</i></dt><dd>
<p>
       Connects to reaction
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p></dd>
<dt>species: <i>void</i></dt><dd>
<p>
       Shared message for connecting to species objects
</p></dd>
<dt>mesh:    <i>void</i></dt><dd>
<p>
       Shared message for dealing with mesh operations
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-22" class="outline-3">
<h3 id="sec-1-22"><span class="section-number-3">1.22</span> GHK</h3>
<div class="outline-text-3" id="text-1-22">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Membrane current
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal Potential
</p></dd>
<dt>T:       <i>double</i></dt><dd>
<p>
       Temperature of system
</p></dd>
<dt>p:       <i>double</i></dt><dd>
<p>
       Permeability of channel
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Membrane potential
</p></dd>
<dt>Cin:     <i>double</i></dt><dd>
<p>
       Internal concentration
</p></dd>
<dt>Cout:    <i>double</i></dt><dd>
<p>
       External ion concentration
</p></dd>
<dt>valency: <i>double</i></dt><dd>
<p>
       Valence of ion
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Relay of membrane potential Vm.
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       MembraneCurrent.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>handleVm:        <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>addPermeability: <i>double</i></dt><dd>
<p>
       Handles permeability message coming in from channel
</p></dd>
<dt>CinDest: <i>double</i></dt><dd>
<p>
       Alias for set<sub>Cin</sub>
</p></dd>
<dt>CoutDest:        <i>double</i></dt><dd>
<p>
       Alias for set<sub>Cout</sub>
</p></dd>
<dt>addPermeability: <i>double</i></dt><dd>
<p>
       Handles permeability message coming in from channel
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message to couple channel to compartment. The first entry is a MsgSrc to send Gk and Ek to the compartment The second entry is a MsgDest for Vm from the compartment.
</p></dd>
<dt>ghk:     <i>void</i></dt><dd>
<p>
       Message from channel to current Goldman-Hodgkin-Katz objectThis shared message connects to an HHChannel. The first entry is a MsgSrc which relays the Vm received from a compartment. The second entry is a MsgDest which receives channel conductance, and interprets it as permeability.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-23" class="outline-3">
<h3 id="sec-1-23"><span class="section-number-3">1.23</span> Geometry</h3>
<div class="outline-text-3" id="text-1-23">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>epsilon: <i>double</i></dt><dd>
<p>
       epsilon is the max deviation of surface-point from surface.I think it refers to when the molecule is stuck to the surface. Need to check with Steven.
</p></dd>
<dt>neighdist:       <i>double</i></dt><dd>
<p>
       neighdist is capture distance from one panel to another.When a molecule diffuses off one panel and is within neighdist of the other, it is captured by the second.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>returnSize:      <i>double</i></dt><dd>
<p>
       Return size of compartment
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleSizeRequest:       <i>void</i></dt><dd>
<p>
       Handles a request for size. Part of SharedMsg to ChemCompt.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>compt:   <i>void</i></dt><dd>
<p>
       Connects to compartment(s) to specify geometry.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-24" class="outline-3">
<h3 id="sec-1-24"><span class="section-number-3">1.24</span> Group</h3>
<div class="outline-text-3" id="text-1-24">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-25" class="outline-3">
<h3 id="sec-1-25"><span class="section-number-3">1.25</span> GslIntegrator</h3>
<div class="outline-text-3" id="text-1-25">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>isInitialized:   <i>bool</i></dt><dd>
<p>
       True if the Stoich message has come in to set parms
</p></dd>
<dt>method:  <i>string</i></dt><dd>
<p>
       Numerical method to use.
</p></dd>
<dt>relativeAccuracy:        <i>double</i></dt><dd>
<p>
       Accuracy criterion
</p></dd>
<dt>absoluteAccuracy:        <i>double</i></dt><dd>
<p>
       Another accuracy criterion
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>stoich:  <i>Id</i></dt><dd>
<p>
       Handle data from Stoich
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-26" class="outline-3">
<h3 id="sec-1-26"><span class="section-number-3">1.26</span> GssaStoich</h3>
<div class="outline-text-3" id="text-1-26">

<p>   Author:              Upinder S. Bhalla, 2008, 2011, NCBS
</p>
<p>   
   Description:         GssaStoich: Gillespie Stochastic Simulation Algorithm object.Closely based on the Stoich object and inherits its handling functions for constructing the matrix. Sets up stoichiometry matrix based calculations from a
   wildcard path for the reaction system.Knows how to compute derivatives for most common things, also knows how to handle special cases where the object will have to do its own computation.Generates a stoichiometry matrix, which is useful for lots of other operations as well.
</p>
<p>   
   Name:                GssaStoich
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>useOneWayReacs:  <i>bool</i></dt><dd>
<p>
       Flag: use bidirectional or one-way reacs. One-way is neededfor Gillespie type stochastic calculations. Two-way islikely to be margninally more efficient in ODE calculations
</p></dd>
<dt>nVarPools:       <i>unsigned int</i></dt><dd>
<p>
       Number of variable molecule pools in the reac system
</p></dd>
<dt>numMeshEntries:  <i>unsigned int</i></dt><dd>
<p>
       Number of meshEntries in reac-diff system
</p></dd>
<dt>estimatedDt:     <i>double</i></dt><dd>
<p>
       Estimate of fastest (smallest) timescale in system.This is fallible because it depends on instantaneous concs,which of course change over the course of the simulation.
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       Path of reaction system to take over
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       Path of reaction system to take over and solve
</p></dd>
<dt>method:  <i>string</i></dt><dd>
<p>
       Numerical method to use for the GssaStoich. The defaultand currently the only method is Gillespie1.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>plugin:  <i>Id</i></dt><dd>
<p>
       Sends out Stoich Id so that plugins can directly access fields and functions
</p></dd>
<dt>nodeDiffBoundary:        <i>unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Sends mol #s across boundary between nodes, to calculate diffusionterms. arg1 is originating node, arg2 is list of meshIndices forwhich data is being transferred, and arg3 are the 'n' values forall the pools on the specified meshIndices, to be plugged intothe appropriate place on the recipient node's S_ matrix
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Handles message from ChemMesh that defines how meshEntries are decomposed on this node, and how they communicate between nodes.Args: (oldVol, volumeVectorForAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#])
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinint call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-27" class="outline-3">
<h3 id="sec-1-27"><span class="section-number-3">1.27</span> HDF5DataWriter</h3>
<div class="outline-text-3" id="text-1-27">

<p>   Author:              Subhasis Ray
</p>
<p>   
   Description:         HDF5 file writer for saving data tables. It saves the tables added to it via addObject function into an HDF5 file. At every process call it writes the contents of the tables to the file and clears the table vectors. You can explicitly save the data via the flush function.
</p>
<p>   
   Name:                HDF5DataWriter
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>filename:        <i>string</i></dt><dd>
<p>
       Name of the file associated with this HDF5 writer object.
</p></dd>
<dt>isOpen:  <i>bool</i></dt><dd>
<p>
       True if this object has an open file handle.
</p></dd>
<dt>mode:    <i>unsigned int</i></dt><dd>
<p>
       Depending on mode, if file already exists, if mode=1, data will be appended to existing file, if mode=2, file will be truncated, if  mode=4, no writing will happen.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>requestData:     <i>unsigned int</i></dt><dd>
<p>
       Sends request for a field to target object
</p></dd>
<dt>clear:   <i>void</i></dt><dd>
<p>
       Send request to clear a Table vector.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>flush:   <i>void</i></dt><dd>
<p>
       Write all buffer contents to file and clear the buffers.
</p></dd>
<dt>recvData:        <i>bad</i></dt><dd>
<p>
       Handles data sent back following request
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handle process calls. Write data to file and clear all Table objects associated with this.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Reinitialize the object
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message to receive process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-28" class="outline-3">
<h3 id="sec-1-28"><span class="section-number-3">1.28</span> HDF5WriterBase</h3>
<div class="outline-text-3" id="text-1-28">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>filename:        <i>string</i></dt><dd>
<p>
       Name of the file associated with this HDF5 writer object.
</p></dd>
<dt>isOpen:  <i>bool</i></dt><dd>
<p>
       True if this object has an open file handle.
</p></dd>
<dt>mode:    <i>unsigned int</i></dt><dd>
<p>
       Depending on mode, if file already exists, if mode=1, data will be appended to existing file, if mode=2, file will be truncated, if  mode=4, no writing will happen.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>flush:   <i>void</i></dt><dd>
<p>
       Write all buffer contents to file and clear the buffers.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-29" class="outline-3">
<h3 id="sec-1-29"><span class="section-number-3">1.29</span> HHChannel</h3>
<div class="outline-text-3" id="text-1-29">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>Xpower:  <i>double</i></dt><dd>
<p>
       Power for X gate
</p></dd>
<dt>Ypower:  <i>double</i></dt><dd>
<p>
       Power for Y gate
</p></dd>
<dt>Zpower:  <i>double</i></dt><dd>
<p>
       Power for Z gate
</p></dd>
<dt>instant: <i>int</i></dt><dd>
<p>
       Bitmapped flag: bit 0 = Xgate, bit 1 = Ygate, bit 2 = ZgateWhen true, specifies that the lookup table value should beused directly as the state of the channel, rather than usedas a rate term for numerical integration for the state
</p></dd>
<dt>X:       <i>double</i></dt><dd>
<p>
       State variable for X gate
</p></dd>
<dt>Y:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p></dd>
<dt>Z:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p></dd>
<dt>useConcentration:        <i>int</i></dt><dd>
<p>
       Flag: when true, use concentration message rather than Vm tocontrol Z gate
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>concen:  <i>double</i></dt><dd>
<p>
       Incoming message from Concen object to specific conc to usein the Z gate calculations
</p></dd>
<dt>createGate:      <i>string</i></dt><dd>
<p>
       Function to create specified gate.Argument: Gate type [X Y Z]
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message to couple channel to compartment. The first entry is a MsgSrc to send Gk and Ek to the compartment The second entry is a MsgDest for Vm from the compartment.
</p></dd>
<dt>ghk:     <i>void</i></dt><dd>
<p>
       Message to Goldman-Hodgkin-Katz object
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process message from thescheduler. The first entry is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt andso on.
        The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-30" class="outline-3">
<h3 id="sec-1-30"><span class="section-number-3">1.30</span> HHChannel2D</h3>
<div class="outline-text-3" id="text-1-30">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>Xindex:  <i>string</i></dt><dd>
<p>
       String for setting X index.
</p></dd>
<dt>Yindex:  <i>string</i></dt><dd>
<p>
       String for setting Y index.
</p></dd>
<dt>Zindex:  <i>string</i></dt><dd>
<p>
       String for setting Z index.
</p></dd>
<dt>Xpower:  <i>double</i></dt><dd>
<p>
       Power for X gate
</p></dd>
<dt>Ypower:  <i>double</i></dt><dd>
<p>
       Power for Y gate
</p></dd>
<dt>Zpower:  <i>double</i></dt><dd>
<p>
       Power for Z gate
</p></dd>
<dt>instant: <i>int</i></dt><dd>
<p>
       Bitmapped flag: bit 0 = Xgate, bit 1 = Ygate, bit 2 = ZgateWhen true, specifies that the lookup table value should beused directly as the state of the channel, rather than usedas a rate term for numerical integration for the state
</p></dd>
<dt>X:       <i>double</i></dt><dd>
<p>
       State variable for X gate
</p></dd>
<dt>Y:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p></dd>
<dt>Z:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>concen:  <i>double</i></dt><dd>
<p>
       Incoming message from Concen object to specific conc to useas the first concen variable
</p></dd>
<dt>concen2: <i>double</i></dt><dd>
<p>
       Incoming message from Concen object to specific conc to useas the second concen variable
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message to couple channel to compartment. The first entry is a MsgSrc to send Gk and Ek to the compartment The second entry is a MsgDest for Vm from the compartment.
</p></dd>
<dt>ghk:     <i>void</i></dt><dd>
<p>
       Message to Goldman-Hodgkin-Katz object
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process message from thescheduler. The first entry is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt andso on.
        The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-31" class="outline-3">
<h3 id="sec-1-31"><span class="section-number-3">1.31</span> HHGate</h3>
<div class="outline-text-3" id="text-1-31">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>alpha:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Parameters for voltage-dependent rates, alpha:Set up alpha term using 5 parameters, as follows:y(x) = (A + B * x) / (C + exp((x + D) / F))The original HH equations can readily be cast into this form
</p></dd>
<dt>beta:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Parameters for voltage-dependent rates, beta:Set up beta term using 5 parameters, as follows:y(x) = (A + B * x) / (C + exp((x + D) / F))The original HH equations can readily be cast into this form
</p></dd>
<dt>tau:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Parameters for voltage-dependent rates, tau:Set up tau curve using 5 parameters, as follows:y(x) = (A + B * x) / (C + exp((x + D) / F))
</p></dd>
<dt>mInfinity:       <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Parameters for voltage-dependent rates, mInfinity:Set up mInfinity curve using 5 parameters, as follows:y(x) = (A + B * x) / (C + exp((x + D) / F))The original HH equations can readily be cast into this form
</p></dd>
<dt>min:     <i>double</i></dt><dd>
<p>
       Minimum range for lookup
</p></dd>
<dt>max:     <i>double</i></dt><dd>
<p>
       Minimum range for lookup
</p></dd>
<dt>divs:    <i>unsigned int</i></dt><dd>
<p>
       Divisions for lookup. Zero means to use linear interpolation
</p></dd>
<dt>tableA:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Table of A entries
</p></dd>
<dt>tableB:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Table of alpha + beta entries
</p></dd>
<dt>useInterpolation:        <i>bool</i></dt><dd>
<p>
       Flag: use linear interpolation if true, else direct lookup
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>setupAlpha:      <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Set up both gates using 13 parameters, as follows:setupAlpha AA AB AC AD AF BA BB BC BD BF xdivs xmin xmaxHere AA-AF are Coefficients A to F of the alpha (forward) termHere BA-BF are Coefficients A to F of the beta (reverse) termHere xdivs is the number of entries in the table,xmin and xmax define the range for lookup.Outside this range the returned value will be the low [high]entry of the table.The equation describing each table is:y(x) = (A + B * x) / (C + exp((x + D) / F))The original HH equations can readily be cast into this form
</p></dd>
<dt>setupTau:        <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Identical to setupAlpha, except that the forms specified bythe 13 parameters are for the tau and m-infinity curves ratherthan the alpha and beta terms. So the parameters are:setupTau TA TB TC TD TF MA MB MC MD MF xdivs xmin xmaxAs before, the equation describing each curve is:y(x) = (A + B * x) / (C + exp((x + D) / F))
</p></dd>
<dt>tweakAlpha:      <i>void</i></dt><dd>
<p>
       Dummy function for backward compatibility. It used to convertthe tables from alpha, beta values to alpha, alpha+betabecause the internal calculations used these forms. Notneeded now, deprecated.
</p></dd>
<dt>tweakTau:        <i>void</i></dt><dd>
<p>
       Dummy function for backward compatibility. It used to convertthe tables from tau, minf values to alpha, alpha+betabecause the internal calculations used these forms. Notneeded now, deprecated.
</p></dd>
<dt>setupGate:       <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Sets up one gate at a time using the alpha/beta form.Has 9 parameters, as follows:setupGate A B C D F xdivs xmin xmax is<sub>betaThis</sub> sets up the gate using the equation:y(x) = (A + B * x) / (C + exp((x + D) / F))Deprecated.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>A:       <i>double,double</i></dt><dd>
<p>
       lookupA: Look up the A gate value from a double. Usually doesso by direct scaling and offset to an integer lookup, usinga fine enough table granularity that there is little error.Alternatively uses linear interpolation.The range of the double is predefined based on knowledge ofvoltage or conc ranges, and the granularity is specified bythe xmin, xmax, and dV fields.
</p></dd>
<dt>B:       <i>double,double</i></dt><dd>
<p>
       lookupB: Look up the B gate value from a double.Note that this looks up the raw tables, which are transformedfrom the reference parameters.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-32" class="outline-3">
<h3 id="sec-1-32"><span class="section-number-3">1.32</span> HHGate2D</h3>
<div class="outline-text-3" id="text-1-32">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>A:       <i>vector&lt;double&gt;,double</i></dt><dd>
<p>
       lookupA: Look up the A gate value from two doubles, passedin as a vector. Uses linear interpolation in the 2D tableThe range of the lookup doubles is predefined based on knowledge of voltage or conc ranges, and the granularity is specified by the xmin, xmax, and dx field, and their y-axis counterparts.
</p></dd>
<dt>B:       <i>vector&lt;double&gt;,double</i></dt><dd>
<p>
       lookupB: Look up B gate value from two doubles in a vector.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-33" class="outline-3">
<h3 id="sec-1-33"><span class="section-number-3">1.33</span> HSolve</h3>
<div class="outline-text-3" id="text-1-33">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>seed:    <i>Id</i></dt><dd>
<p>
       Use this field to specify path to a 'seed' compartment, that is, any compartment within a neuron. The HSolve object uses this seed as a handle to discover the rest of the neuronal model, which means all the remaining compartments, channels, synapses, etc.
</p></dd>
<dt>target:  <i>string</i></dt><dd>
<p>
       Specifies the path to a compartmental model to be taken over. This can be the path to any container object that has the model under it (found by performing a deep search). Alternatively, this can also be the path to any compartment within the neuron. This compartment will be used as a handle to discover the rest of the model, which means all the remaining compartments, channels, synapses, etc.
</p></dd>
<dt>dt:      <i>double</i></dt><dd>
<p>
       The time-step for this solver.
</p></dd>
<dt>caAdvance:       <i>int</i></dt><dd>
<p>
       This flag determines how current flowing into a calcium pool is computed. A value of 0 means that the membrane potential at the beginning of the time-step is used for the calculation. This is how GENESIS does its computations. A value of 1 means the membrane potential at the middle of the time-step is used. This is the correct way of integration, and is the default way.
</p></dd>
<dt>vDiv:    <i>int</i></dt><dd>
<p>
       Specifies number of divisions for lookup tables of voltage-sensitive channels.
</p></dd>
<dt>vMin:    <i>double</i></dt><dd>
<p>
       Specifies the lower bound for lookup tables of voltage-sensitive channels. Default is to automatically decide based on the tables of the channels that the solver reads in.
</p></dd>
<dt>vMax:    <i>double</i></dt><dd>
<p>
       Specifies the upper bound for lookup tables of voltage-sensitive channels. Default is to automatically decide based on the tables of the channels that the solver reads in.
</p></dd>
<dt>caDiv:   <i>int</i></dt><dd>
<p>
       Specifies number of divisions for lookup tables of calcium-sensitive channels.
</p></dd>
<dt>caMin:   <i>double</i></dt><dd>
<p>
       Specifies the lower bound for lookup tables of calcium-sensitive channels. Default is to automatically decide based on the tables of the channels that the solver reads in.
</p></dd>
<dt>caMax:   <i>double</i></dt><dd>
<p>
       Specifies the upper bound for lookup tables of calcium-sensitive channels. Default is to automatically decide based on the tables of the channels that the solver reads in.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles 'process' call: Solver advances by one time-step.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles 'reinit' call: Solver reads in model.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Handles 'reinit' and 'process' calls from a clock.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-34" class="outline-3">
<h3 id="sec-1-34"><span class="section-number-3">1.34</span> HemispherePanel</h3>
<div class="outline-text-3" id="text-1-34">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-35" class="outline-3">
<h3 id="sec-1-35"><span class="section-number-3">1.35</span> IntFire</h3>
<div class="outline-text-3" id="text-1-35">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>numSynapses:     <i>unsigned int</i></dt><dd>
<p>
       Number of synapses on SynBase
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Membrane potential
</p></dd>
<dt>tau:     <i>double</i></dt><dd>
<p>
       charging time-course
</p></dd>
<dt>thresh:  <i>double</i></dt><dd>
<p>
       firing threshold
</p></dd>
<dt>refractoryPeriod:        <i>double</i></dt><dd>
<p>
       Minimum time between successive spikes
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>spike:   <i>double</i></dt><dd>
<p>
       Sends out spike events
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-36" class="outline-3">
<h3 id="sec-1-36"><span class="section-number-3">1.36</span> Interpol2D</h3>
<div class="outline-text-3" id="text-1-36">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>xmin:    <i>double</i></dt><dd>
<p>
       Minimum value for x axis of lookup table
</p></dd>
<dt>xmax:    <i>double</i></dt><dd>
<p>
       Maximum value for x axis of lookup table
</p></dd>
<dt>xdivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on x axis of lookup table
</p></dd>
<dt>dx:      <i>double</i></dt><dd>
<p>
       Increment on x axis of lookup table
</p></dd>
<dt>ymin:    <i>double</i></dt><dd>
<p>
       Minimum value for y axis of lookup table
</p></dd>
<dt>ymax:    <i>double</i></dt><dd>
<p>
       Maximum value for y axis of lookup table
</p></dd>
<dt>ydivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on y axis of lookup table
</p></dd>
<dt>dy:      <i>double</i></dt><dd>
<p>
       Increment on y axis of lookup table
</p></dd>
<dt>tableVector2D:   <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Get the entire table.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>trig:    <i>double</i></dt><dd>
<p>
       respond to a request for a value lookup
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>lookup:  <i>double,double</i></dt><dd>
<p>
       Looks up table value based on indices v1 and v2, and sendsvalue back using the 'trig' message
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>lookupReturn2D:  <i>void</i></dt><dd>
<p>
       This is a shared message for doing lookups on the table. Receives 2 doubles: x, y. Sends back a double with the looked-up z value.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>table:   <i>vector&lt;unsigned int&gt;,double</i></dt><dd>
<p>
       Lookup an entry on the table
</p></dd>
<dt>z:       <i>vector&lt;double&gt;,double</i></dt><dd>
<p>
       Interpolated value for specified x and y. This is provided for debugging. Normally other objects will retrieve interpolated values via lookup message.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-37" class="outline-3">
<h3 id="sec-1-37"><span class="section-number-3">1.37</span> IzhikevichNrn</h3>
<div class="outline-text-3" id="text-1-37">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Vmax:    <i>double</i></dt><dd>
<p>
       Maximum membrane potential. Membrane potential is reset to c whenever it reaches Vmax. NOTE: Izhikevich model specifies the PEAK voltage, rather than THRSHOLD voltage. The threshold depends on the previous history.
</p></dd>
<dt>c:       <i>double</i></dt><dd>
<p>
       Reset potential. Membrane potential is reset to c whenever it reaches Vmax.
</p></dd>
<dt>d:       <i>double</i></dt><dd>
<p>
       Parameter d in Izhikevich model. Unit is V/s.
</p></dd>
<dt>a:       <i>double</i></dt><dd>
<p>
       Parameter a in Izhikevich model. Unit is s<sup>-1</sup>
</p></dd>
<dt>b:       <i>double</i></dt><dd>
<p>
       Parameter b in Izhikevich model. Unit is s<sup>-1</sup>
</p></dd>
<dt>u:       <i>double</i></dt><dd>
<p>
       Parameter u in Izhikevich equation. Unit is V/s<sup>-1</sup>
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Membrane potential, equivalent to v in Izhikevich equation.
</p></dd>
<dt>Im:      <i>double</i></dt><dd>
<p>
       Total current going through the membrane. Unit is A.
</p></dd>
<dt>Rm:      <i>double</i></dt><dd>
<p>
       Hidden cefficient of input current term (I) in Izhikevich model. Defaults to 1e6 Ohm.
</p></dd>
<dt>initVm:  <i>double</i></dt><dd>
<p>
       Initial membrane potential. Unit is V.
</p></dd>
<dt>initU:   <i>double</i></dt><dd>
<p>
       Initial value of u.
</p></dd>
<dt>alpha:   <i>double</i></dt><dd>
<p>
       Coefficient of v<sup>2</sup> in Izhikevich equation. Defaults to 0.04 in physiological unit. In SI it should be 40000.0. Unit is V<sup>-1</sup> s<sup>-1</sup>
</p></dd>
<dt>beta:    <i>double</i></dt><dd>
<p>
       Coefficient of v in Izhikevich model. Defaults to 5 in physiological unit, 5000.0 for SI units. Unit is s<sup>-1</sup>
</p></dd>
<dt>gamma:   <i>double</i></dt><dd>
<p>
       Constant term in Izhikevich model. Defaults to 140 in both physiological and SI units. unit is V/s.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Sends out Vm
</p></dd>
<dt>spike:   <i>double</i></dt><dd>
<p>
       Sends out spike events
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>injectDest:      <i>double</i></dt><dd>
<p>
       Injection current into the neuron.
</p></dd>
<dt>cDest:   <i>double</i></dt><dd>
<p>
       Destination message to modify parameter c at runtime.
</p></dd>
<dt>dDest:   <i>double</i></dt><dd>
<p>
       Destination message to modify parameter d at runtime.
</p></dd>
<dt>bDest:   <i>double</i></dt><dd>
<p>
       Destination message to modify parameter b at runtime
</p></dd>
<dt>aDest:   <i>double</i></dt><dd>
<p>
       Destination message modify parameter a at runtime.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message to receive Process message from scheduler
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-38" class="outline-3">
<h3 id="sec-1-38"><span class="section-number-3">1.38</span> LeakyIaF</h3>
<div class="outline-text-3" id="text-1-38">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Cm:      <i>double</i></dt><dd>
<p>
       Membrane capacitance.
</p></dd>
<dt>Rm:      <i>double</i></dt><dd>
<p>
       Membrane resistance, inverse of leak-conductance.
</p></dd>
<dt>Em:      <i>double</i></dt><dd>
<p>
       Leak reversal potential
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Membrane potential
</p></dd>
<dt>initVm:  <i>double</i></dt><dd>
<p>
       Inital value of membrane potential
</p></dd>
<dt>Vreset:  <i>double</i></dt><dd>
<p>
       Reset potnetial after firing.
</p></dd>
<dt>Vthreshold:      <i>double</i></dt><dd>
<p>
       firing threshold
</p></dd>
<dt>refractoryPeriod:        <i>double</i></dt><dd>
<p>
       Minimum time between successive spikes
</p></dd>
<dt>inject:  <i>double</i></dt><dd>
<p>
       Injection current.
</p></dd>
<dt>tSpike:  <i>double</i></dt><dd>
<p>
       Time of the last spike
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>spike:   <i>double</i></dt><dd>
<p>
       Sends out spike events
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Sends out Vm
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>injectDest:      <i>double</i></dt><dd>
<p>
       Destination for current input.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-39" class="outline-3">
<h3 id="sec-1-39"><span class="section-number-3">1.39</span> MMenz</h3>
<div class="outline-text-3" id="text-1-39">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>sub:     <i>void</i></dt><dd>
<p>
       Connects to substrate molecule
</p></dd>
<dt>prd:     <i>void</i></dt><dd>
<p>
       Connects to product molecule
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-40" class="outline-3">
<h3 id="sec-1-40"><span class="section-number-3">1.40</span> MarkovChannel</h3>
<div class="outline-text-3" id="text-1-40">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>ligandconc:      <i>double</i></dt><dd>
<p>
       Ligand concentration.
</p></dd>
<dt>vm:      <i>double</i></dt><dd>
<p>
       Membrane voltage.
</p></dd>
<dt>numstates:       <i>unsigned int</i></dt><dd>
<p>
       The number of states that the channel can occupy.
</p></dd>
<dt>numopenstates:   <i>unsigned int</i></dt><dd>
<p>
       The number of states which are open/conducting.
</p></dd>
<dt>state:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       This is a row vector that contains the probabilities of finding the channel in each state.
</p></dd>
<dt>initialstate:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       This is a row vector that contains the probabilities of finding the channel in each state at t = 0. The state of the channel is reset to this value during a call to reinit()
</p></dd>
<dt>labels:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Labels for each state.
</p></dd>
<dt>gbar:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       A row vector containing the conductance associated with each of the open/conducting states.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleligandconc:        <i>double</i></dt><dd>
<p>
       Deals with incoming messages containing information of ligand concentration
</p></dd>
<dt>handlestate:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Deals with incoming message from MarkovSolver object containing state information of the channel.
</p></dd>
</dl>

</li>
</ul>



<ul>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message to couple channel to compartment. The first entry is a MsgSrc to send Gk and Ek to the compartment The second entry is a MsgDest for Vm from the compartment.
</p></dd>
<dt>ghk:     <i>void</i></dt><dd>
<p>
       Message to Goldman-Hodgkin-Katz object
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process message from thescheduler. The first entry is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt andso on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-41" class="outline-3">
<h3 id="sec-1-41"><span class="section-number-3">1.41</span> MarkovGslSolver</h3>
<div class="outline-text-3" id="text-1-41">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>isInitialized:   <i>bool</i></dt><dd>
<p>
       True if the message has come in to set solver parameters.
</p></dd>
<dt>method:  <i>string</i></dt><dd>
<p>
       Numerical method to use.
</p></dd>
<dt>relativeAccuracy:        <i>double</i></dt><dd>
<p>
       Accuracy criterion
</p></dd>
<dt>absoluteAccuracy:        <i>double</i></dt><dd>
<p>
       Another accuracy criterion
</p></dd>
<dt>internalDt:      <i>double</i></dt><dd>
<p>
       internal timestep to use.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>stateOut:        <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Sends updated state to the MarkovChannel class.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>init:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Initialize solver parameters.
</p></dd>
<dt>handleQ: <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Handles information regarding the instantaneous rate matrix from the MarkovRateTable class.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-42" class="outline-3">
<h3 id="sec-1-42"><span class="section-number-3">1.42</span> MarkovRateTable</h3>
<div class="outline-text-3" id="text-1-42">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>vm:      <i>double</i></dt><dd>
<p>
       Membrane voltage.
</p></dd>
<dt>ligandconc:      <i>double</i></dt><dd>
<p>
       Ligand concentration.
</p></dd>
<dt>Q:       <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Instantaneous rate matrix.
</p></dd>
<dt>size:    <i>unsigned int</i></dt><dd>
<p>
       Dimension of the families of lookup tables. Is always equal to the number of states in the model.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>instratesOut:    <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Sends out instantaneous rate information of varying transition rates at each time step.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleVm:        <i>double</i></dt><dd>
<p>
       Handles incoming message containing voltage information.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>init:    <i>unsigned int</i></dt><dd>
<p>
       Initialization of the class. Allocates memory for all the tables.
</p></dd>
<dt>handleLigandConc:        <i>double</i></dt><dd>
<p>
       Handles incoming message containing ligand concentration.
</p></dd>
<dt>set1d:   <i>unsigned int,unsigned int,Id,unsigned int</i></dt><dd>
<p>
       Setting up of 1D lookup table for the (i,j)'th rate.
</p></dd>
<dt>set2d:   <i>unsigned int,unsigned int,Id</i></dt><dd>
<p>
       Setting up of 2D lookup table for the (i,j)'th rate.
</p></dd>
<dt>setconst:        <i>unsigned int,unsigned int,double</i></dt><dd>
<p>
       Setting a constant value for the (i,j)'th rate. Internally, this is      stored as a 1-D rate with a lookup table containing 1 entry.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This message couples the rate table to the compartment. The rate table needs updates on voltage in order to compute the rate table.
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process message from thescheduler. The first entry is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt andso on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-43" class="outline-3">
<h3 id="sec-1-43"><span class="section-number-3">1.43</span> MarkovSolver</h3>
<div class="outline-text-3" id="text-1-43">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Q:       <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Instantaneous rate matrix.
</p></dd>
<dt>state:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Current state of the channel.
</p></dd>
<dt>initialstate:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Initial state of the channel.
</p></dd>
<dt>xmin:    <i>double</i></dt><dd>
<p>
       Minimum value for x axis of lookup table
</p></dd>
<dt>xmax:    <i>double</i></dt><dd>
<p>
       Maximum value for x axis of lookup table
</p></dd>
<dt>xdivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on x axis of lookup table
</p></dd>
<dt>invdx:   <i>double</i></dt><dd>
<p>
       Reciprocal of increment on x axis of lookup table
</p></dd>
<dt>ymin:    <i>double</i></dt><dd>
<p>
       Minimum value for y axis of lookup table
</p></dd>
<dt>ymax:    <i>double</i></dt><dd>
<p>
       Maximum value for y axis of lookup table
</p></dd>
<dt>ydivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on y axis of lookup table
</p></dd>
<dt>invdy:   <i>double</i></dt><dd>
<p>
       Reciprocal of increment on y axis of lookup table
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>stateOut:        <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Sends updated state to the MarkovChannel class.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleVm:        <i>double</i></dt><dd>
<p>
       Handles incoming message containing voltage information.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>ligandconc:      <i>double</i></dt><dd>
<p>
       Handles incoming message containing ligand concentration.
</p></dd>
<dt>init:    <i>Id,double</i></dt><dd>
<p>
       Setups the table of matrix exponentials associated with the solver object.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This message couples the MarkovSolverBase to the Compartment. The compartment needs Vm in order to look up the correct matrix exponential for computing the state.
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process message from thescheduler. The first entry is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt andso on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo.
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process message from thescheduler. The first entry is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt andso on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-44" class="outline-3">
<h3 id="sec-1-44"><span class="section-number-3">1.44</span> MarkovSolverBase</h3>
<div class="outline-text-3" id="text-1-44">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Q:       <i>vector&lt; vector&lt;double&gt; &gt;</i></dt><dd>
<p>
       Instantaneous rate matrix.
</p></dd>
<dt>state:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Current state of the channel.
</p></dd>
<dt>initialstate:    <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Initial state of the channel.
</p></dd>
<dt>xmin:    <i>double</i></dt><dd>
<p>
       Minimum value for x axis of lookup table
</p></dd>
<dt>xmax:    <i>double</i></dt><dd>
<p>
       Maximum value for x axis of lookup table
</p></dd>
<dt>xdivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on x axis of lookup table
</p></dd>
<dt>invdx:   <i>double</i></dt><dd>
<p>
       Reciprocal of increment on x axis of lookup table
</p></dd>
<dt>ymin:    <i>double</i></dt><dd>
<p>
       Minimum value for y axis of lookup table
</p></dd>
<dt>ymax:    <i>double</i></dt><dd>
<p>
       Maximum value for y axis of lookup table
</p></dd>
<dt>ydivs:   <i>unsigned int</i></dt><dd>
<p>
       # of divisions on y axis of lookup table
</p></dd>
<dt>invdy:   <i>double</i></dt><dd>
<p>
       Reciprocal of increment on y axis of lookup table
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>stateOut:        <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Sends updated state to the MarkovChannel class.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleVm:        <i>double</i></dt><dd>
<p>
       Handles incoming message containing voltage information.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>ligandconc:      <i>double</i></dt><dd>
<p>
       Handles incoming message containing ligand concentration.
</p></dd>
<dt>init:    <i>Id,double</i></dt><dd>
<p>
       Setups the table of matrix exponentials associated with the solver object.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This message couples the MarkovSolverBase to the Compartment. The compartment needs Vm in order to look up the correct matrix exponential for computing the state.
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process message from thescheduler. The first entry is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt andso on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-45" class="outline-3">
<h3 id="sec-1-45"><span class="section-number-3">1.45</span> MathFunc</h3>
<div class="outline-text-3" id="text-1-45">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>mathML:  <i>string</i></dt><dd>
<p>
       MathML version of expression to compute
</p></dd>
<dt>function:        <i>string</i></dt><dd>
<p>
       function is for functions of form f(x, y) = x + y
</p></dd>
<dt>result:  <i>double</i></dt><dd>
<p>
       result value
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Sends out result of computation
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>arg1:    <i>double</i></dt><dd>
<p>
       Handle arg1
</p></dd>
<dt>arg2:    <i>double</i></dt><dd>
<p>
       Handle arg2
</p></dd>
<dt>arg3:    <i>double</i></dt><dd>
<p>
       Handle arg3
</p></dd>
<dt>arg4:    <i>double</i></dt><dd>
<p>
       Handle arg4
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handle process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handle reinit call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-46" class="outline-3">
<h3 id="sec-1-46"><span class="section-number-3">1.46</span> Mdouble</h3>
<div class="outline-text-3" id="text-1-46">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>this:    <i>double</i></dt><dd>
<p>
       Access function for entire Mdouble object.
</p></dd>
<dt>value:   <i>double</i></dt><dd>
<p>
       Access function for value field of Mdouble object,which happens also to be the entire contents of the object.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-47" class="outline-3">
<h3 id="sec-1-47"><span class="section-number-3">1.47</span> MeshEntry</h3>
<div class="outline-text-3" id="text-1-47">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Volume of this MeshEntry
</p></dd>
<dt>dimensions:      <i>unsigned int</i></dt><dd>
<p>
       number of dimensions of this MeshEntry
</p></dd>
<dt>meshType:        <i>unsigned int</i></dt><dd>
<p>
        The MeshType defines the shape of the mesh entry. 0: Not assigned 1: cuboid 2: cylinder 3. cylindrical shell 4: cylindrical shell segment 5: sphere 6: spherical shell 7: spherical shell segment 8: Tetrahedral
</p></dd>
<dt>Coordinates:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Coordinates that define current MeshEntry. Depend on MeshType.
</p></dd>
<dt>neighbors:       <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Indices of other MeshEntries that this one connects to
</p></dd>
<dt>DiffusionArea:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Diffusion area for geometry of interface
</p></dd>
<dt>DiffusionScaling:        <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Diffusion scaling for geometry of interface
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Tells the target pool or other entity that the compartment subdivision(meshing) has changed, and that it has to redo its volume and memory allocation accordingly.Arguments are: oldvol, numTotalEntries, startEntry, localIndices, volsThe vols specifies volumes of each local mesh entry. It also specifieshow many meshEntries are present on the local node.The localIndices vector is used for general load balancing only.It has a list of the all meshEntries on current node.If it is empty, we assume block load balancing. In this secondcase the contents of the current node go from startEntry to startEntry + vols.size().
</p></dd>
<dt>remeshReacs:     <i>void</i></dt><dd>
<p>
       Tells connected enz or reac that the compartment subdivision(meshing) has changed, and that it has to redo its volume-dependent rate terms like numKf_ accordingly.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p></dd>
<dt>mesh:    <i>void</i></dt><dd>
<p>
       Shared message for updating mesh volumes and subdivisions,typically controls pool sizes
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-48" class="outline-3">
<h3 id="sec-1-48"><span class="section-number-3">1.48</span> MgBlock</h3>
<div class="outline-text-3" id="text-1-48">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>KMg<sub>A</sub>:   <i>double</i></dt><dd>
<p>
       1/eta
</p></dd>
<dt>KMg<sub>B</sub>:   <i>double</i></dt><dd>
<p>
       1/gamma
</p></dd>
<dt>CMg:     <i>double</i></dt><dd>
<p>
       [Mg] in mM
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Current through MgBlock
</p></dd>
<dt>Zk:      <i>double</i></dt><dd>
<p>
       Charge on ion
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>origChannel:     <i>double,double</i></dt><dd>
</dd>
</dl>

</li>
</ul>



<ul>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message to couple channel to compartment. The first entry is a MsgSrc to send Gk and Ek to the compartment The second entry is a MsgDest for Vm from the compartment.
</p></dd>
<dt>ghk:     <i>void</i></dt><dd>
<p>
       Message to Goldman-Hodgkin-Katz object
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-49" class="outline-3">
<h3 id="sec-1-49"><span class="section-number-3">1.49</span> Msg</h3>
<div class="outline-text-3" id="text-1-49">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-50" class="outline-3">
<h3 id="sec-1-50"><span class="section-number-3">1.50</span> Mstring</h3>
<div class="outline-text-3" id="text-1-50">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>this:    <i>string</i></dt><dd>
<p>
       Access function for entire Mstring object.
</p></dd>
<dt>value:   <i>string</i></dt><dd>
<p>
       Access function for value field of Mstring object,which happens also to be the entire contents of the object.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-51" class="outline-3">
<h3 id="sec-1-51"><span class="section-number-3">1.51</span> NMDAChan</h3>
<div class="outline-text-3" id="text-1-51">

<p>   Author:              Subhasis Ray, 2010, NCBS
</p>
<p>   
   Description:         NMDAChan: Extracellular [Mg2+] dependent NMDA channel.This channel has four states as described by Jahr and Stevens (J. Neurosci. 1990, 10(9)) This implementation is based on equation 4(a) in that article. The channel conductance is defined as : k * g(V, [Mg2+]o) * S(t) where k is a scaling constant. S(t) is the legand gated component of the conductance. It rises linearly for t = tau2. Then decays exponentially with time constant t = tau1. g is a function of voltage and the extracellular [Mg2+] defined as: 1 / { 1 + (a1 + a2) * (a1 * B1 + a2 * B2)/ [A * a1 * (b1 + B1) + A * a2 * (b2 + B2)]} a1 = 1e3 * exp( - c0 * V - c1) s<sup>-1</sup>, c0 = 16.0 / V, c1 = 2.91 a2 = 1e-3 * [Mg2+] * exp( -c2 * V - c3) mM<sup>-1</sup> s, c2 = 45.0 / V, c3 = 6.97 b1 = 1e3 * exp(c4  * V + c5) s<sup>-1</sup>, c4 = 9.0 / V, c5 = 1.22 b2 = 1e3 * exp(c6 * V + c7) s<sup>-1</sup>, c6 = 17.0 / V, c7 = 0.96 A = 1e3 * exp(-c8) s<sup>-1</sup>, c8 = 2.847 B1 = 1e3 * exp(-c9) s<sup>-1</sup>, c9 = 0.693 s<sup>-1</sup> B2 = 1e3 * exp(-c10) s<sup>-1</sup>, c10 = 3.101. The behaviour of S(t) is as follows: If a spike arrives, then the slope of the linear rise of S(t) is incremented by weight / tau2. After tau2 time, this component is removed from the slope (reduced by weight/tau) and added over to the rate of decay of S(t).
</p>
<p>   
   Name:                NMDAChan
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>numSynapses:     <i>unsigned int</i></dt><dd>
<p>
       Number of synapses on SynBase
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>tau1:    <i>double</i></dt><dd>
<p>
       Decay time constant for the synaptic conductance, tau1 &gt;= tau2.
</p></dd>
<dt>tau2:    <i>double</i></dt><dd>
<p>
       Rise time constant for the synaptic conductance, tau1 &gt;= tau2.
</p></dd>
<dt>normalizeWeights:        <i>bool</i></dt><dd>
<p>
       Flag. If true, the overall conductance is normalized by the number of individual synapses in this SynChan object.
</p></dd>
<dt>unblocked:       <i>double</i></dt><dd>
<p>
       Fraction of channels recovered from Mg2+ block. This is an intermediate variable which corresponds to g(V, [Mg2+]o)  in the equation for conductance: k * g(V, [Mg2+]o) * S(t) where k is a constant.
</p></dd>
<dt>MgConc:  <i>double</i></dt><dd>
<p>
       External Mg2+ concentration
</p></dd>
<dt>unblocked:       <i>double</i></dt><dd>
<p>
       Fraction of channels recovered from Mg2+ block. This is an intermediate variable which corresponds to g(V, [Mg2+]o)  in the equation for conductance: k * g(V, [Mg2+]o) * S(t) where k is a constant.
</p></dd>
<dt>saturation:      <i>double</i></dt><dd>
<p>
       Upper limit on the NMDA conductance.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>activation:      <i>double</i></dt><dd>
<p>
       Sometimes we want to continuously activate the channel
</p></dd>
<dt>modulator:       <i>double</i></dt><dd>
<p>
       Modulate channel response
</p></dd>
<dt>MgConcDest:      <i>double</i></dt><dd>
<p>
       Update [Mg2+] from other sources at every time step.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message to couple channel to compartment. The first entry is a MsgSrc to send Gk and Ek to the compartment The second entry is a MsgDest for Vm from the compartment.
</p></dd>
<dt>ghk:     <i>void</i></dt><dd>
<p>
       Message to Goldman-Hodgkin-Katz object
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message to receive Process message from scheduler
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>c:       <i>unsigned int,double</i></dt><dd>
<p>
       Transition parameters c0 to c10 in the Mg2+ dependentstate transitions.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-52" class="outline-3">
<h3 id="sec-1-52"><span class="section-number-3">1.52</span> Nernst</h3>
<div class="outline-text-3" id="text-1-52">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>E:       <i>double</i></dt><dd>
<p>
       Computed reversal potential
</p></dd>
<dt>Temperature:     <i>double</i></dt><dd>
<p>
       Temperature of cell
</p></dd>
<dt>valence: <i>int</i></dt><dd>
<p>
       Valence of ion in Nernst calculation
</p></dd>
<dt>Cin:     <i>double</i></dt><dd>
<p>
       Internal conc of ion
</p></dd>
<dt>Cout:    <i>double</i></dt><dd>
<p>
       External conc of ion
</p></dd>
<dt>scale:   <i>double</i></dt><dd>
<p>
       Voltage scale factor
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>Eout:    <i>double</i></dt><dd>
<p>
       Computed reversal potential
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>ci:      <i>double</i></dt><dd>
<p>
       Set internal conc of ion, and immediately send out the updated E
</p></dd>
<dt>co:      <i>double</i></dt><dd>
<p>
       Set external conc of ion, and immediately send out the updated E
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-53" class="outline-3">
<h3 id="sec-1-53"><span class="section-number-3">1.53</span> NeuroMesh</h3>
<div class="outline-text-3" id="text-1-53">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of entire chemical domain.Assigning this assumes that the geometry is that of the default mesh, which may not be what you want. If so, usea more specific mesh assignment function.
</p></dd>
<dt>numDimensions:   <i>unsigned int</i></dt><dd>
<p>
       Number of spatial dimensions of this compartment. Usually 3 or 2
</p></dd>
<dt>cell:    <i>Id</i></dt><dd>
<p>
       Id for base element of cell model. Uses this to traverse theentire tree of the cell to build the mesh.
</p></dd>
<dt>subTree: <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       Set of compartments to model. If they happen to be contiguousthen also set up diffusion between the compartments. Can alsohandle cases where the same cell is divided into multiplenon-diffusively-coupled compartments
</p></dd>
<dt>skipSpines:      <i>bool</i></dt><dd>
<p>
       Flag: when skipSpines is true, the traversal does not includeany compartment with the string 'spine' or 'neck' in its name,and also then skips compartments below this skipped one.Allows to set up separate mesh for spines, based on the same cell model.
</p></dd>
<dt>numSegments:     <i>unsigned int</i></dt><dd>
<p>
       Number of cylindrical/spherical segments in model
</p></dd>
<dt>numDiffCompts:   <i>unsigned int</i></dt><dd>
<p>
       Number of diffusive compartments in model
</p></dd>
<dt>diffLength:      <i>double</i></dt><dd>
<p>
       Diffusive length constant to use for subdivisions. The system willattempt to subdivide cell using diffusive compartments ofthe specified diffusion lengths as a maximum.In order to get integral numbersof compartments in each segment, it may subdivide more finely.Uses default of 0.5 microns, that is, half typical lambda.For default, consider a tau of about 1 second for mostreactions, and a diffusion const of about 1e-12 um<sup>2</sup>/sec.This gives lambda of 1 micron
</p></dd>
<dt>geometryPolicy:  <i>string</i></dt><dd>
<p>
       Policy for how to interpret electrical model geometry (which is a branching 1-dimensional tree) in terms of 3-D constructslike spheres, cylinders, and cones.There are three options, default, trousers, and cylinder:default mode: - Use frustrums of cones. Distal diameter is always from compt dia. - For linear dendrites (no branching), proximal diameter is  diameter of the parent compartment - For branching dendrites and dendrites emerging from soma, proximal diameter is from compt dia. Don't worry about overlap. - Place somatic dendrites on surface of spherical soma, or at ends of cylindrical soma - Place dendritic spines on surface of cylindrical dendrites, not emerging from their middle.trousers mode: - Use frustrums of cones. Distal diameter is always from compt dia. - For linear dendrites (no branching), proximal diameter is  diameter of the parent compartment - For branching dendrites, use a trouser function. Avoid overlap. - For soma, use some variant of trousers. Here we must avoid overlap - For spines, use a way to smoothly merge into parent dend. Radius of curvature should be similar to that of the spine neck. - Place somatic dendrites on surface of spherical soma, or at ends of cylindrical soma - Place dendritic spines on surface of cylindrical dendrites, not emerging from their middle.cylinder mode: - Use cylinders. Diameter is just compartment dia. - Place somatic dendrites on surface of spherical soma, or at ends of cylindrical soma - Place dendritic spines on surface of cylindrical dendrites, not emerging from their middle. - Ignore spatial overlap.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Defines how meshEntries communicate between nodes.Args: oldVol, volListOfAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#]This message is meant to go to the SimManager and Stoich.
</p></dd>
<dt>meshStats:       <i>unsigned int,vector&lt;double&gt;</i></dt><dd>
<p>
       Basic statistics for mesh: Total # of entries, and a vector ofunique volumes of voxels
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>buildDefaultMesh:        <i>double,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh derived class to build a default mesh with thespecified size and number of meshEntries.
</p></dd>
<dt>handleRequestMeshStats:  <i>void</i></dt><dd>
<p>
       Handles request from SimManager for mesh stats
</p></dd>
<dt>handleNodeInfo:  <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Tells ChemMesh how many nodes and threads per node it is allowed to use. Triggers a return meshSplit message.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>nodeMeshing:     <i>void</i></dt><dd>
<p>
       Connects to SimManager to coordinate meshing with paralleldecomposition and with the Stoich
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-54" class="outline-3">
<h3 id="sec-1-54"><span class="section-number-3">1.54</span> Neuron</h3>
<div class="outline-text-3" id="text-1-54">

<p>   Author:              C H Chaitanya
</p>
<p>   
   Description:         Neuron - A compartment container
</p>
<p>   
   Name:                Neuron
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-55" class="outline-3">
<h3 id="sec-1-55"><span class="section-number-3">1.55</span> Neutral</h3>
<div class="outline-text-3" id="text-1-55">

<p>   Author:              Upinder S. Bhalla, 2007, NCBS
</p>
<p>   
   Description:         Neutral: Base class for all MOOSE classes. Providesaccess functions for housekeeping fields and operations, messagetraversal, and so on.
</p>
<p>   
   Name:                Neutral
</p>
<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-56" class="outline-3">
<h3 id="sec-1-56"><span class="section-number-3">1.56</span> OneToAllMsg</h3>
<div class="outline-text-3" id="text-1-56">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p></dd>
<dt>i1:      <i>DataId</i></dt><dd>
<p>
       DataId of source Element.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-57" class="outline-3">
<h3 id="sec-1-57"><span class="section-number-3">1.57</span> OneToOneMsg</h3>
<div class="outline-text-3" id="text-1-57">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-58" class="outline-3">
<h3 id="sec-1-58"><span class="section-number-3">1.58</span> PIDController</h3>
<div class="outline-text-3" id="text-1-58">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>gain:    <i>double</i></dt><dd>
<p>
       This is the proportional gain (Kp). This tuning parameter scales the proportional term. Larger gain usually results in faster response, but too much will lead to instability and oscillation.
</p></dd>
<dt>saturation:      <i>double</i></dt><dd>
<p>
       Bound on the permissible range of output. Defaults to maximum double value.
</p></dd>
<dt>command: <i>double</i></dt><dd>
<p>
       The command (desired) value of the sensed parameter. In control theory this is commonly known as setpoint(SP).
</p></dd>
<dt>sensed:  <i>double</i></dt><dd>
<p>
       Sensed (measured) value. This is commonly known as process variable(PV) in control theory.
</p></dd>
<dt>tauI:    <i>double</i></dt><dd>
<p>
       The integration time constant, typically = dt. This is actually proportional gain divided by integral gain (Kp/Ki)). Larger Ki (smaller tauI) usually leads to fast elimination of steady state errors at the cost of larger overshoot.
</p></dd>
<dt>tauD:    <i>double</i></dt><dd>
<p>
       The differentiation time constant, typically = dt / 4. This is derivative gain (Kd) times proportional gain (Kp). Larger Kd (tauD) decreases overshoot at the cost of slowing down transient response and may lead to instability.
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Output of the PIDController. This is given by:      gain * ( error + INTEGRAL[ error dt ] / tau<sub>i</sub>   + tau<sub>d</sub> * d(error)/dt )
       Where gain = proportional gain (Kp), tau<sub>i</sub> = integral gain (Kp/Ki) and tau<sub>d</sub> = derivative gain (Kd/Kp). In control theory this is also known as the manipulated variable (MV)
</p></dd>
<dt>error:   <i>double</i></dt><dd>
<p>
       The error term, which is the difference between command and sensed value.
</p></dd>
<dt>integral:        <i>double</i></dt><dd>
<p>
       The integral term. It is calculated as INTEGRAL(error dt) = previous<sub>integral</sub> + dt * (error + e<sub>previous</sub>)/2.
</p></dd>
<dt>derivative:      <i>double</i></dt><dd>
<p>
       The derivative term. This is (error - e<sub>previous</sub>)/dt.
</p></dd>
<dt>e<sub>previous</sub>:      <i>double</i></dt><dd>
<p>
       The error term for previous step.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>outputOut:       <i>double</i></dt><dd>
<p>
       Sends the output of the PIDController. This is known as manipulated variable (MV) in control theory. This should be fed into the process which we are trying to control.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>commandIn:       <i>double</i></dt><dd>
<p>
       Command (desired value) input. This is known as setpoint (SP) in control theory.
</p></dd>
<dt>sensedIn:        <i>double</i></dt><dd>
<p>
       Sensed parameter - this is the one to be tuned. This is known as process variable (PV) in control theory. This comes from the process we are trying to control.
</p></dd>
<dt>gainDest:        <i>double</i></dt><dd>
<p>
       Destination message to control the PIDController gain dynamically.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handle process calls.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Reinitialize the object.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process messages from the scheduler objects.The first entry in the shared msg is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt and so on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo. 
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-59" class="outline-3">
<h3 id="sec-1-59"><span class="section-number-3">1.59</span> Panel</h3>
<div class="outline-text-3" id="text-1-59">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-60" class="outline-3">
<h3 id="sec-1-60"><span class="section-number-3">1.60</span> Pool</h3>
<div class="outline-text-3" id="text-1-60">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p></dd>
<dt>increment:       <i>double</i></dt><dd>
<p>
       Increments mol numbers by specified amount. Can be +ve or -ve
</p></dd>
<dt>decrement:       <i>double</i></dt><dd>
<p>
       Decrements mol numbers by specified amount. Can be +ve or -ve
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>reac:    <i>void</i></dt><dd>
<p>
       Connects to reaction
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p></dd>
<dt>species: <i>void</i></dt><dd>
<p>
       Shared message for connecting to species objects
</p></dd>
<dt>mesh:    <i>void</i></dt><dd>
<p>
       Shared message for dealing with mesh operations
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-61" class="outline-3">
<h3 id="sec-1-61"><span class="section-number-3">1.61</span> PoolBase</h3>
<div class="outline-text-3" id="text-1-61">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>reac:    <i>void</i></dt><dd>
<p>
       Connects to reaction
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p></dd>
<dt>species: <i>void</i></dt><dd>
<p>
       Shared message for connecting to species objects
</p></dd>
<dt>mesh:    <i>void</i></dt><dd>
<p>
       Shared message for dealing with mesh operations
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-62" class="outline-3">
<h3 id="sec-1-62"><span class="section-number-3">1.62</span> Port</h3>
<div class="outline-text-3" id="text-1-62">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>scaleOutRate:    <i>double</i></dt><dd>
<p>
       Scaling factor for outgoing rates. Applies to the RateTermscontrolled by this port. Represents a diffusion related term,or the permeability of the port
</p></dd>
<dt>inStart: <i>unsigned int</i></dt><dd>
<p>
       Start index to S_ vector into which incoming molecules should add.
</p></dd>
<dt>inEnd:   <i>unsigned int</i></dt><dd>
<p>
       End index to S_ vector into which incoming molecules should add.
</p></dd>
<dt>outStart:        <i>unsigned int</i></dt><dd>
<p>
       Start index to S_ vector from where outgoing molecules come.
</p></dd>
<dt>outEnd:  <i>unsigned int</i></dt><dd>
<p>
       End index to S_ vector from where outgoing molecules come.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>availableMolsAtPort:     <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       Sends out the full set of molecule Ids that are available for data transfer
</p></dd>
<dt>efflux:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Molecule #s going out
</p></dd>
<dt>matchedMolsAtPort:       <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       Sends out the set of molecule Ids that match between both ports
</p></dd>
<dt>efflux:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Molecule #s going out
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleMatchedMolsAtPort: <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Handles list of matched molecules worked out by the other port
</p></dd>
<dt>influx:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Molecule #s coming back in
</p></dd>
<dt>handleAvailableMolsAtPort:       <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Handles list of all species that the other port cares about
</p></dd>
<dt>influx:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       Molecule #s coming back in
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>port1:   <i>void</i></dt><dd>
<p>
       Shared message for port. This one initiates the request forsetting up the communications between the portsThe shared message also handles the runtime data transfer
</p></dd>
<dt>port2:   <i>void</i></dt><dd>
<p>
       Shared message for port. This one responds to the request forsetting up the communications between the portsThe shared message also handles the runtime data transfer
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-63" class="outline-3">
<h3 id="sec-1-63"><span class="section-number-3">1.63</span> PulseGen</h3>
<div class="outline-text-3" id="text-1-63">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Output amplitude
</p></dd>
<dt>baseLevel:       <i>double</i></dt><dd>
<p>
       Basal level of the stimulus
</p></dd>
<dt>firstLevel:      <i>double</i></dt><dd>
<p>
       Amplitude of the first pulse in a sequence
</p></dd>
<dt>firstWidth:      <i>double</i></dt><dd>
<p>
       Width of the first pulse in a sequence
</p></dd>
<dt>firstDelay:      <i>double</i></dt><dd>
<p>
       Delay to start of the first pulse in a sequence
</p></dd>
<dt>secondLevel:     <i>double</i></dt><dd>
<p>
       Amplitude of the second pulse in a sequence
</p></dd>
<dt>secondWidth:     <i>double</i></dt><dd>
<p>
       Width of the second pulse in a sequence
</p></dd>
<dt>secondDelay:     <i>double</i></dt><dd>
<p>
       Delay to start of of the second pulse in a sequence
</p></dd>
<dt>count:   <i>unsigned int</i></dt><dd>
<p>
       Number of pulses in a sequence
</p></dd>
<dt>trigMode:        <i>unsigned int</i></dt><dd>
<p>
       Trigger mode for pulses in the sequence.
        0 : free-running mode where it keeps looping its output
        1 : external trigger, where it is triggered by an external input (and stops after creating the first train of pulses)
        2 : external gate mode, where it keeps generating the pulses in a loop as long as the input is high.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>outputOut:       <i>double</i></dt><dd>
<p>
       Current output level.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Handle incoming input that determines gating/triggering onset.
</p></dd>
<dt>levelIn: <i>unsigned int,double</i></dt><dd>
<p>
       Handle level value coming from other objects
</p></dd>
<dt>widthIn: <i>unsigned int,double</i></dt><dd>
<p>
       Handle width value coming from other objects
</p></dd>
<dt>delayIn: <i>unsigned int,double</i></dt><dd>
<p>
       Handle delay value coming from other objects
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call, updates internal time stamp.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process messages from the scheduler objects.The first entry in the shared msg is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt and so on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo. 
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>level:   <i>unsigned int,double</i></dt><dd>
<p>
       Level of the pulse at specified index
</p></dd>
<dt>width:   <i>unsigned int,double</i></dt><dd>
<p>
       Width of the pulse at specified index
</p></dd>
<dt>delay:   <i>unsigned int,double</i></dt><dd>
<p>
       Delay of the pulse at specified index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-64" class="outline-3">
<h3 id="sec-1-64"><span class="section-number-3">1.64</span> RC</h3>
<div class="outline-text-3" id="text-1-64">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>V0:      <i>double</i></dt><dd>
<p>
       Initial value of 'state'
</p></dd>
<dt>R:       <i>double</i></dt><dd>
<p>
       Series resistance of the RC circuit.
</p></dd>
<dt>C:       <i>double</i></dt><dd>
<p>
       Parallel capacitance of the RC circuit.
</p></dd>
<dt>state:   <i>double</i></dt><dd>
<p>
       Output value of the RC circuit. This is the voltage across the capacitor.
</p></dd>
<dt>inject:  <i>double</i></dt><dd>
<p>
       Input value to the RC circuit.This is handled as an input current to the circuit.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>outputOut:       <i>double</i></dt><dd>
<p>
       Current output level.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>injectIn:        <i>double</i></dt><dd>
<p>
       Receives input to the RC circuit. All incoming messages are summed up to give the total input current.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handle reinitialization
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process messages from the scheduler objects.The first entry in the shared msg is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt and so on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo. 
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-65" class="outline-3">
<h3 id="sec-1-65"><span class="section-number-3">1.65</span> Reac</h3>
<div class="outline-text-3" id="text-1-65">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in # units
</p></dd>
<dt>kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in # units
</p></dd>
<dt>Kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in concentration units
</p></dd>
<dt>Kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in concentration units
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates of reaction
</p></dd>
<dt>numProducts:     <i>unsigned int</i></dt><dd>
<p>
       Number of products of reaction
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the reac to recompute its numRates, as remeshing has happened
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>sub:     <i>void</i></dt><dd>
<p>
       Connects to substrate pool
</p></dd>
<dt>prd:     <i>void</i></dt><dd>
<p>
       Connects to substrate pool
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-66" class="outline-3">
<h3 id="sec-1-66"><span class="section-number-3">1.66</span> ReacBase</h3>
<div class="outline-text-3" id="text-1-66">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in # units
</p></dd>
<dt>kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in # units
</p></dd>
<dt>Kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in concentration units
</p></dd>
<dt>Kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in concentration units
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates of reaction
</p></dd>
<dt>numProducts:     <i>unsigned int</i></dt><dd>
<p>
       Number of products of reaction
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the reac to recompute its numRates, as remeshing has happened
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>sub:     <i>void</i></dt><dd>
<p>
       Connects to substrate pool
</p></dd>
<dt>prd:     <i>void</i></dt><dd>
<p>
       Connects to substrate pool
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-67" class="outline-3">
<h3 id="sec-1-67"><span class="section-number-3">1.67</span> RectPanel</h3>
<div class="outline-text-3" id="text-1-67">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-68" class="outline-3">
<h3 id="sec-1-68"><span class="section-number-3">1.68</span> ReduceMsg</h3>
<div class="outline-text-3" id="text-1-68">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p></dd>
<dt>i1:      <i>DataId</i></dt><dd>
<p>
       DataId of source Element.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-69" class="outline-3">
<h3 id="sec-1-69"><span class="section-number-3">1.69</span> Shell</h3>
<div class="outline-text-3" id="text-1-69">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>reduceArraySize: <i>unsigned int</i></dt><dd>
<p>
       Look up maximum value of an index, here ragged array size,across many nodes, and assign uniformly to all nodes. Normallyfollowed by an operation to assign the size to the object thatwas resized.
</p></dd>
<dt>requestCreate:   <i>string,Id,Id,string,vector&lt;int&gt;</i></dt><dd>
<p>
       requestCreate( class, parent, newElm, name, dimensions ): creates a new Element on all nodes with the specified Id. Initiates a callback to indicate completion of operation. Goes to all nodes including self.
</p></dd>
<dt>requestDelete:   <i>Id</i></dt><dd>
<p>
       requestDelete( doomedElement ):Deletes specified Element on all nodes.Initiates a callback to indicate completion of operation.Goes to all nodes including self.
</p></dd>
<dt>requestAddMsg:   <i>string,unsigned int,ObjId,string,ObjId,string</i></dt><dd>
<p>
       requestAddMsg( type, src, srcField, dest, destField );Creates specified Msg between specified Element on all nodes.Initiates a callback to indicate completion of operation.Goes to all nodes including self.
</p></dd>
<dt>requestQuit:     <i>void</i></dt><dd>
<p>
       requestQuit():Emerges from the inner loop, and wraps up. No return value.
</p></dd>
<dt>move:    <i>Id,Id</i></dt><dd>
<p>
       move( origId, newParent);Moves origId to become a child of newParent
</p></dd>
<dt>copy:    <i>vector&lt;Id&gt;,string,unsigned int,bool,bool</i></dt><dd>
<p>
       copy( origId, newParent, numRepeats, toGlobal, copyExtMsg );Copies origId to become a child of newParent
</p></dd>
<dt>useClock:        <i>string,string,unsigned int</i></dt><dd>
<p>
       useClock( path, field, tick# );Specifies which clock tick to use for all elements in Path.The 'field' is typically process, but some cases need to sendupdates to the 'init' field.Tick # specifies which tick to be attached to the objects.
</p></dd>
<dt>sync:    <i>Id,unsigned int</i></dt><dd>
<p>
       sync( ElementId, FuncId );Synchronizes Element data indexing across all nodes.Used when distributed ops like message setup might set updifferent #s of data entries on Elements on different nodes.The ElementId is the element being synchronized.The FuncId is the 'get' function for the synchronized field.
</p></dd>
<dt>requestReMesh:   <i>Id</i></dt><dd>
<p>
       requestReMesh( meshId );Chops up specified mesh.
</p></dd>
<dt>requestSetParserIdleFlag:        <i>bool</i></dt><dd>
<p>
       SetParserIdleFlag( bool isParserIdle );When True, the main ProcessLoop waits a little each cycleso as to avoid pounding on the CPU.
</p></dd>
<dt>ack:     <i>unsigned int,unsigned int</i></dt><dd>
<p>
       ack( unsigned int node#, unsigned int status ):Acknowledges receipt and completion of a command on a worker node.Goes back only to master node.
</p></dd>
<dt>requestStart:    <i>double</i></dt><dd>
<p>
       requestStart( runtime ):Starts a simulation. Goes to all nodes including self.Initiates a callback to indicate completion of run.
</p></dd>
<dt>requestStep:     <i>unsigned int</i></dt><dd>
<p>
       requestStep():Advances a simulation for the specified # of steps.Goes to all nodes including self.
</p></dd>
<dt>requestStop:     <i>void</i></dt><dd>
<p>
       requestStop():Gently stops a simulation after completing current ops.After this op it is save to do 'start' again, and it willresume where it left offGoes to all nodes including self.
</p></dd>
<dt>requestSetupTick:        <i>unsigned int,double</i></dt><dd>
<p>
       requestSetupTick():Asks the Clock to coordinate the assignment of a specificclock tick. Args: Tick#, dt.Goes to all nodes including self.
</p></dd>
<dt>requestReinit:   <i>void</i></dt><dd>
<p>
       requestReinit():Reinits a simulation: sets to time 0.If simulation is running it stops it first.Goes to all nodes including self.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>receiveGet:      <i>bad</i></dt><dd>
<p>
       receiveGet( Uint node#, Uint status, PrepackedBuffer data )Function on master shell that handles the value relayed from worker.
</p></dd>
<dt>setclock:        <i>unsigned int,double,bool</i></dt><dd>
<p>
       Assigns clock ticks. Args: tick#, dt
</p></dd>
<dt>handleAck:       <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Keeps track of # of acks to a blocking shell command. Arg: Source node num.
</p></dd>
<dt>create:  <i>string,Id,Id,string,vector&lt;int&gt;</i></dt><dd>
<p>
       create( class, parent, newElm, name, dimensions )
</p></dd>
<dt>delete:  <i>Id</i></dt><dd>
<p>
       Destroys Element, all its messages, and all its children. Args: Id
</p></dd>
<dt>handleAddMsg:    <i>string,unsigned int,ObjId,string,ObjId,string</i></dt><dd>
<p>
       Makes a msg
</p></dd>
<dt>handleQuit:      <i>void</i></dt><dd>
<p>
       Stops simulation running and quits the simulator
</p></dd>
<dt>move:    <i>Id,Id</i></dt><dd>
<p>
       handleMove( Id orig, Id newParent ): moves an Element to a new parent
</p></dd>
<dt>handleCopy:      <i>vector&lt;Id&gt;,string,unsigned int,bool,bool</i></dt><dd>
<p>
       handleCopy( vector&lt; Id &gt; args, string newName, unsigned int nCopies, bool toGlobal, bool copyExtMsgs ):  The vector&lt; Id &gt; has Id orig, Id newParent, Id newElm. This function copies an Element and all its children to a new parent. May also expand out the original into nCopies copies. Normally all messages within the copy tree are also copied.  If the flag copyExtMsgs is true, then all msgs going out are also copied.
</p></dd>
<dt>handleUseClock:  <i>string,string,unsigned int</i></dt><dd>
<p>
       Deals with assignment of path to a given clock.
</p></dd>
<dt>handleSync:      <i>Id,unsigned int</i></dt><dd>
<p>
       handleSync( Id Element): Synchronizes DataHandler indexing across nodesThe ElementId is the element being synchronized.The FuncId is the 'get' function for the synchronized field.
</p></dd>
<dt>handleReMesh:    <i>Id</i></dt><dd>
<p>
       handleReMesh( Id BaseMesh): Deals with outcome of resizing the meshing in a cellularcompartment (the ChemMesh class). The mesh change has topropagate down to the molecules and reactions managed by this.Mesh. The ElementId is the mesh being synchronized.
</p></dd>
<dt>handleSetParserIdleFlag: <i>bool</i></dt><dd>
<p>
       handleSetParserIdleFlag( bool isParserIdle ): When True, tells the ProcessLoop to wait as the Parser is idle.
</p></dd>
<dt>handleAck:       <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Keeps track of # of acks to a blocking shell command. Arg: Source node num.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>master:  <i>void</i></dt><dd>
<p>
       Issues commands from master shell to worker shells located on different nodes. Also handles acknowledgements from them.
</p></dd>
<dt>worker:  <i>void</i></dt><dd>
<p>
       Handles commands arriving from master shell on node 0.Sends out acknowledgements from them.
</p></dd>
<dt>clockControl:    <i>void</i></dt><dd>
<p>
       Controls the system Clock
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-70" class="outline-3">
<h3 id="sec-1-70"><span class="section-number-3">1.70</span> SimManager</h3>
<div class="outline-text-3" id="text-1-70">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>syncTime:        <i>double</i></dt><dd>
<p>
       SyncTime is the interval between synchronizing solvers5 msec is a typical value
</p></dd>
<dt>autoPlot:        <i>bool</i></dt><dd>
<p>
       When the autoPlot flag is true, the simManager guesses whichplots are of interest, and builds them.
</p></dd>
<dt>plotDt:  <i>double</i></dt><dd>
<p>
       plotDt is the timestep for plotting variables. As most will bechemical, a default of 1 sec is reasonable
</p></dd>
<dt>runTime: <i>double</i></dt><dd>
<p>
       runTime is the requested duration of the simulation that is stored in some kinds of model definition files.
</p></dd>
<dt>method:  <i>string</i></dt><dd>
<p>
       method is the numerical method used for the calculations.This will set up or even replace the solver with one ableto use the specified method. Currently works only with two solvers: GSL and GSSA.The GSL solver has a variety of ODE methods, by defaultRunge-Kutta-Fehlberg.The GSSA solver currently uses the Gillespie StochasticSystems Algorithm, somewhat optimized over the originalmethod.
</p></dd>
<dt>version: <i>unsigned int</i></dt><dd>
<p>
       Numerical version number. Used by kkit
</p></dd>
<dt>modelFamily:     <i>string</i></dt><dd>
<p>
       Family classification of model: *kinetic, and *neuron are the options so far. In due course expect to see thingslike detailedNetwork, intFireNetwork, sigNeur and so on.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>requestMeshStats:        <i>void</i></dt><dd>
<p>
       Asks for basic stats for mesh:Total # of entries, and a vector of unique volumes of voxels
</p></dd>
<dt>nodeInfo:        <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Sends out # of nodes to use for meshing, and # of threads to use on each node, to the ChemMesh. These numbers sometimesdiffer from the total # of nodes and threads, because the SimManager may have other portions of the model to allocate.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>build:   <i>string</i></dt><dd>
<p>
       Sets up model, with the specified method. The method may beempty if the intention is that methods be set up through hints in the ChemMesh compartments.
</p></dd>
<dt>makeStandardElements:    <i>string</i></dt><dd>
<p>
       Sets up the usual infrastructure for a model, with theChemMesh, Stoich, solver and suitable messaging.The argument is the MeshClass to use.
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;unsigned int&gt;,vector&lt;unsigned int&gt;,vector&lt;unsigned int&gt;,vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Handles message from ChemMesh that defines howmeshEntries communicate between nodes.First arg is oldvol, next is list of other nodes, third arg is list number ofmeshEntries to be transferred for each of these nodes, fourth arg is catenated list of meshEntries indices onmy node going to each of the other connected nodes, andlast arg is matching list of meshEntries on other nodes
</p></dd>
<dt>meshStats:       <i>unsigned int,vector&lt;double&gt;</i></dt><dd>
<p>
       Basic statistics for mesh: Total # of entries, and a vectorof unique volumes of voxels
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>nodeMeshing:     <i>void</i></dt><dd>
<p>
       Connects to ChemMesh to coordinate meshing with paralleldecomposition and with the Stoich
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-71" class="outline-3">
<h3 id="sec-1-71"><span class="section-number-3">1.71</span> SingleMsg</h3>
<div class="outline-text-3" id="text-1-71">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p></dd>
<dt>i1:      <i>DataId</i></dt><dd>
<p>
       Index of source object.
</p></dd>
<dt>i2:      <i>DataId</i></dt><dd>
<p>
       Index of dest object.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-72" class="outline-3">
<h3 id="sec-1-72"><span class="section-number-3">1.72</span> SparseMsg</h3>
<div class="outline-text-3" id="text-1-72">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>e1:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>e2:      <i>Id</i></dt><dd>
<p>
       Id of source Element.
</p></dd>
<dt>srcFieldsOnE1:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e1 to e2. There arematching entries in the destFieldsOnE2 vector
</p></dd>
<dt>destFieldsOnE2:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of DestFinfos for messages going from e1 to e2. There arematching entries in the srcFieldsOnE1 vector
</p></dd>
<dt>srcFieldsOnE2:   <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of SrcFinfos for messages going from e2 to e1. There arematching entries in the destFieldsOnE1 vector
</p></dd>
<dt>destFieldsOnE1:  <i>vector&lt;string&gt;</i></dt><dd>
<p>
       Names of destFinfos for messages going from e2 to e1. There arematching entries in the srcFieldsOnE2 vector
</p></dd>
<dt>numRows: <i>unsigned int</i></dt><dd>
<p>
       Number of rows in matrix.
</p></dd>
<dt>numColumns:      <i>unsigned int</i></dt><dd>
<p>
       Number of columns in matrix.
</p></dd>
<dt>numEntries:      <i>unsigned int</i></dt><dd>
<p>
       Number of Entries in matrix.
</p></dd>
<dt>probability:     <i>double</i></dt><dd>
<p>
       connection probability for random connectivity.
</p></dd>
<dt>seed:    <i>long</i></dt><dd>
<p>
       Random number seed for generating probabilistic connectivity.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>setRandomConnectivity:   <i>double,long</i></dt><dd>
<p>
       Assigns connectivity with specified probability and seed
</p></dd>
<dt>setEntry:        <i>unsigned int,unsigned int,unsigned int</i></dt><dd>
<p>
       Assigns single row,column value
</p></dd>
<dt>unsetEntry:      <i>unsigned int,unsigned int</i></dt><dd>
<p>
       Clears single row,column entry
</p></dd>
<dt>clear:   <i>void</i></dt><dd>
<p>
       Clears out the entire matrix
</p></dd>
<dt>transpose:       <i>void</i></dt><dd>
<p>
       Transposes the sparse matrix
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-73" class="outline-3">
<h3 id="sec-1-73"><span class="section-number-3">1.73</span> Species</h3>
<div class="outline-text-3" id="text-1-73">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>molWt:   <i>double</i></dt><dd>
<p>
       Molecular weight of species
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>sendMolWt:       <i>double</i></dt><dd>
<p>
       returns molWt.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>handleMolWtRequest:      <i>void</i></dt><dd>
<p>
       Handle requests for molWt.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>pool:    <i>void</i></dt><dd>
<p>
       Connects to pools of this Species type
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-74" class="outline-3">
<h3 id="sec-1-74"><span class="section-number-3">1.74</span> SpherePanel</h3>
<div class="outline-text-3" id="text-1-74">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-75" class="outline-3">
<h3 id="sec-1-75"><span class="section-number-3">1.75</span> SpikeGen</h3>
<div class="outline-text-3" id="text-1-75">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>threshold:       <i>double</i></dt><dd>
<p>
       Spiking threshold, must cross it going up
</p></dd>
<dt>refractT:        <i>double</i></dt><dd>
<p>
       Refractory Time.
</p></dd>
<dt>abs<sub>refract</sub>:     <i>double</i></dt><dd>
<p>
       Absolute refractory time. Synonym for refractT.
</p></dd>
<dt>hasFired:        <i>bool</i></dt><dd>
<p>
       True if SpikeGen has just fired
</p></dd>
<dt>edgeTriggered:   <i>bool</i></dt><dd>
<p>
       When edgeTriggered = 0, the SpikeGen will fire an event in each timestep while incoming Vm is &gt; threshold and at least abs<sub>refracttime</sub> has passed since last event. This may be problematic if the incoming Vm remains above threshold for longer than abs<sub>refract</sub>. Setting edgeTriggered to 1 resolves this as the SpikeGen generatesan event only on the rising edge of the incoming Vm and will remain idle unless the incoming Vm goes below threshold.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>event:   <i>double</i></dt><dd>
<p>
       Sends out a trigger for an event.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message to receive Process message from scheduler
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-76" class="outline-3">
<h3 id="sec-1-76"><span class="section-number-3">1.76</span> Stats</h3>
<div class="outline-text-3" id="text-1-76">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>mean:    <i>double</i></dt><dd>
<p>
       Mean of all sampled values.
</p></dd>
<dt>sdev:    <i>double</i></dt><dd>
<p>
       Standard Deviation of all sampled values.
</p></dd>
<dt>sum:     <i>double</i></dt><dd>
<p>
       Sum of all sampled values.
</p></dd>
<dt>num:     <i>unsigned int</i></dt><dd>
<p>
       Number of all sampled values.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>reduce:  <i>unsigned int</i></dt><dd>
<p>
       Execute statistics reduction operation on all targets andplace results in this object
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>trig:    <i>void</i></dt><dd>
<p>
       Triggers Reduction operation.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-77" class="outline-3">
<h3 id="sec-1-77"><span class="section-number-3">1.77</span> StimulusTable</h3>
<div class="outline-text-3" id="text-1-77">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>vec:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       vector with all table entries
</p></dd>
<dt>outputValue:     <i>double</i></dt><dd>
<p>
       Output value holding current table entry or output of a calculation
</p></dd>
<dt>size:    <i>unsigned int</i></dt><dd>
<p>
       size of table. Note that this is the number of x divisions +1since it must represent the largest value as well as thesmallest
</p></dd>
<dt>startTime:       <i>double</i></dt><dd>
<p>
       Start time used when table is emitting values. For lookupvalues below this, the table just sends out its zero entry.Corresponds to zeroth entry of table.
</p></dd>
<dt>stopTime:        <i>double</i></dt><dd>
<p>
       Time to stop emitting values.If time exceeds this, then the table sends out its last entry.The stopTime corresponds to the last entry of table.
</p></dd>
<dt>loopTime:        <i>double</i></dt><dd>
<p>
       If looping, this is the time between successive cycle starts.Defaults to the difference between stopTime and startTime, so that the output waveform cycles with precisely the same duration as the table contents.If larger than stopTime - startTime, then it pauses at the last table value till it is time to go around again.If smaller than stopTime - startTime, then it begins the next cycle even before the first one has reached the end of the table.
</p></dd>
<dt>stepSize:        <i>double</i></dt><dd>
<p>
       Increment in lookup (x) value on every timestep. If it isless than or equal to zero, the StimulusTable uses the current timeas the lookup value.
</p></dd>
<dt>stepPosition:    <i>double</i></dt><dd>
<p>
       Current value of lookup (x) value.If stepSize is less than or equal to zero, this is set tothe current time to use as the lookup value.
</p></dd>
<dt>doLoop:  <i>bool</i></dt><dd>
<p>
       Flag: Should it loop around to startTime once it has reachedstopTime. Default (zero) is to do a single pass.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Sends out tabulated data according to lookup parameters.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>linearTransform: <i>double,double</i></dt><dd>
<p>
       Linearly scales and offsets data. Scale first, then offset.
</p></dd>
<dt>xplot:   <i>string,string</i></dt><dd>
<p>
       Dumps table contents to xplot-format file. Argument 1 is filename, argument 2 is plotname
</p></dd>
<dt>plainPlot:       <i>string</i></dt><dd>
<p>
       Dumps table contents to single-column ascii file. Uses scientific notation. Argument 1 is filename
</p></dd>
<dt>loadCSV: <i>string,int,int,char</i></dt><dd>
<p>
       Reads a single column from a CSV file. Arguments: filename, column#, starting row#, separator
</p></dd>
<dt>loadXplot:       <i>string,string</i></dt><dd>
<p>
       Reads a single plot from an xplot file. Arguments: filename, plotnameWhen the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>loadXplotRange:  <i>string,string,unsigned int,unsigned int</i></dt><dd>
<p>
       Reads a single plot from an xplot file, and selects a subset of points from it. Arguments: filename, plotname, startindex, endindexUses C convention: startindex included, endindex not included.When the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>compareXplot:    <i>string,string,string</i></dt><dd>
<p>
       Reads a plot from an xplot file and compares with contents of TableBase.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: filename, plotname, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>compareVec:      <i>vector&lt;double&gt;,string</i></dt><dd>
<p>
       Compares contents of TableBase with a vector of doubles.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: Other vector, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>clearVec:        <i>void</i></dt><dd>
<p>
       Handles request to clear the data vector
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call, updates internal time stamp.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       Value of table at specified index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-78" class="outline-3">
<h3 id="sec-1-78"><span class="section-number-3">1.78</span> Stoich</h3>
<div class="outline-text-3" id="text-1-78">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>useOneWayReacs:  <i>bool</i></dt><dd>
<p>
       Flag: use bidirectional or one-way reacs. One-way is neededfor Gillespie type stochastic calculations. Two-way islikely to be margninally more efficient in ODE calculations
</p></dd>
<dt>nVarPools:       <i>unsigned int</i></dt><dd>
<p>
       Number of variable molecule pools in the reac system
</p></dd>
<dt>numMeshEntries:  <i>unsigned int</i></dt><dd>
<p>
       Number of meshEntries in reac-diff system
</p></dd>
<dt>estimatedDt:     <i>double</i></dt><dd>
<p>
       Estimate of fastest (smallest) timescale in system.This is fallible because it depends on instantaneous concs,which of course change over the course of the simulation.
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       Path of reaction system to take over
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>plugin:  <i>Id</i></dt><dd>
<p>
       Sends out Stoich Id so that plugins can directly access fields and functions
</p></dd>
<dt>nodeDiffBoundary:        <i>unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Sends mol #s across boundary between nodes, to calculate diffusionterms. arg1 is originating node, arg2 is list of meshIndices forwhich data is being transferred, and arg3 are the 'n' values forall the pools on the specified meshIndices, to be plugged intothe appropriate place on the recipient node's S_ matrix
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>meshSplit:       <i>double,vector&lt;double&gt;,vector&lt;unsigned int&gt;,vector&lt; vector&lt;unsigned int&gt; &gt;,vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Handles message from ChemMesh that defines how meshEntries are decomposed on this node, and how they communicate between nodes.Args: (oldVol, volumeVectorForAllEntries, localEntryList, outgoingDiffusion[node#][entry#], incomingDiffusion[node#][entry#])
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-79" class="outline-3">
<h3 id="sec-1-79"><span class="section-number-3">1.79</span> SumFunc</h3>
<div class="outline-text-3" id="text-1-79">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>result:  <i>double</i></dt><dd>
<p>
       outcome of summation
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Sends out sum on each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Handles input values
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-80" class="outline-3">
<h3 id="sec-1-80"><span class="section-number-3">1.80</span> Surface</h3>
<div class="outline-text-3" id="text-1-80">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>volume:  <i>double</i></dt><dd>
<p>
       This is something I'll need to write a function to compute.Perhaps have an update routine as it may be hard to compute but is needed often by the molecules.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>absorb:  <i>void</i></dt><dd>
<p>
       these help the system define non-standard operations for what a molecule does when it hits a surface.The default is reflect.As a molecule may interact with multiple surfaces, it isn't enough to confer a property on the molecule itself. We have to use messages. Perhaps we don't need these, but instead put entities on the surface which the molecule interacts with if it doesn't do the basic reflect operation.
</p></dd>
<dt>transmit:        <i>void</i></dt><dd>
<p>
       Surface lets molecules through
</p></dd>
<dt>jump:    <i>void</i></dt><dd>
<p>
       dunno
</p></dd>
<dt>mixture: <i>void</i></dt><dd>
<p>
       dunno
</p></dd>
<dt>surface: <i>double,double,double</i></dt><dd>
<p>
       Connects up to a compartment, either as interior or exterior Args are volume, area, perimeter
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-81" class="outline-3">
<h3 id="sec-1-81"><span class="section-number-3">1.81</span> SymCompartment</h3>
<div class="outline-text-3" id="text-1-81">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       membrane potential
</p></dd>
<dt>Cm:      <i>double</i></dt><dd>
<p>
       Membrane capacitance
</p></dd>
<dt>Em:      <i>double</i></dt><dd>
<p>
       Resting membrane potential
</p></dd>
<dt>Im:      <i>double</i></dt><dd>
<p>
       Current going through membrane
</p></dd>
<dt>inject:  <i>double</i></dt><dd>
<p>
       Current injection to deliver into compartment
</p></dd>
<dt>initVm:  <i>double</i></dt><dd>
<p>
       Initial value for membrane potential
</p></dd>
<dt>Rm:      <i>double</i></dt><dd>
<p>
       Membrane resistance
</p></dd>
<dt>Ra:      <i>double</i></dt><dd>
<p>
       Axial resistance of compartment
</p></dd>
<dt>diameter:        <i>double</i></dt><dd>
<p>
       Diameter of compartment
</p></dd>
<dt>length:  <i>double</i></dt><dd>
<p>
       Length of compartment
</p></dd>
<dt>x0:      <i>double</i></dt><dd>
<p>
       X coordinate of start of compartment
</p></dd>
<dt>y0:      <i>double</i></dt><dd>
<p>
       Y coordinate of start of compartment
</p></dd>
<dt>z0:      <i>double</i></dt><dd>
<p>
       Z coordinate of start of compartment
</p></dd>
<dt>x:       <i>double</i></dt><dd>
<p>
       x coordinate of end of compartment
</p></dd>
<dt>y:       <i>double</i></dt><dd>
<p>
       y coordinate of end of compartment
</p></dd>
<dt>z:       <i>double</i></dt><dd>
<p>
       z coordinate of end of compartment
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment on each timestep
</p></dd>
<dt>axialOut:        <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment to adjacent compartments,on each timestep
</p></dd>
<dt>raxialOut:       <i>double,double</i></dt><dd>
<p>
       Sends out Raxial information on each timestep, fields are Ra and Vm
</p></dd>
<dt>raxialOut:       <i>double,double</i></dt><dd>
<p>
       Sends out Ra and Vm on each timestep
</p></dd>
<dt>sumRaxialOut:    <i>double</i></dt><dd>
<p>
       Sends out Ra
</p></dd>
<dt>requestSumAxial: <i>void</i></dt><dd>
<p>
       Sends out request for Ra.
</p></dd>
<dt>raxialOut:       <i>double,double</i></dt><dd>
<p>
       Sends out Ra and Vm on each timestep
</p></dd>
<dt>sumRaxialOut:    <i>double</i></dt><dd>
<p>
       Sends out Ra
</p></dd>
<dt>requestSumAxial: <i>void</i></dt><dd>
<p>
       Sends out request for Ra.
</p></dd>
<dt>Raxial2Out:      <i>double,double</i></dt><dd>
<p>
       Sends out Ra and Vm
</p></dd>
<dt>sumRaxial2Out:   <i>double</i></dt><dd>
<p>
       Sends out Ra
</p></dd>
<dt>requestSumAxial2:        <i>void</i></dt><dd>
<p>
       Sends out request for Ra.
</p></dd>
<dt>Raxial2Out:      <i>double,double</i></dt><dd>
<p>
       Sends out Ra and Vm
</p></dd>
<dt>sumRaxial2Out:   <i>double</i></dt><dd>
<p>
       Sends out Ra
</p></dd>
<dt>requestSumAxial2:        <i>void</i></dt><dd>
<p>
       Sends out request for Ra.
</p></dd>
<dt>Raxial2Out:      <i>double,double</i></dt><dd>
<p>
       Sends out Ra and Vm
</p></dd>
<dt>sumRaxial2Out:   <i>double</i></dt><dd>
<p>
       Sends out Ra
</p></dd>
<dt>requestSumAxial2:        <i>void</i></dt><dd>
<p>
       Sends out request for Ra.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>randInject:      <i>double,double</i></dt><dd>
<p>
       Sends a random injection current to the compartment. Must beupdated each timestep.Arguments to randInject are probability and current.
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>cable:   <i>void</i></dt><dd>
<p>
       Message for organizing compartments into groups, calledcables. Doesn't do anything.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles 'process' call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles 'reinit' call
</p></dd>
<dt>initProc:        <i>void</i></dt><dd>
<p>
       Handles Process call for the 'init' phase of the Compartment calculations. These occur as a separate Tick cycle from the regular proc cycle, and should be called before the proc msg.
</p></dd>
<dt>initReinit:      <i>void</i></dt><dd>
<p>
       Handles Reinit call for the 'init' phase of the Compartment calculations.
</p></dd>
<dt>handleChannel:   <i>double,double</i></dt><dd>
<p>
       Handles conductance and Reversal potential arguments from Channel
</p></dd>
<dt>handleRaxial:    <i>double,double</i></dt><dd>
<p>
       Handles Raxial info: arguments are Ra and Vm.
</p></dd>
<dt>handleAxial:     <i>double</i></dt><dd>
<p>
       Handles Axial information. Argument is just Vm.
</p></dd>
<dt>raxialSym:       <i>double,double</i></dt><dd>
<p>
       Expects Ra and Vm from other compartment.
</p></dd>
<dt>sumRaxial:       <i>double</i></dt><dd>
<p>
       Expects Ra from other compartment.
</p></dd>
<dt>handleSumRaxialRequest:  <i>void</i></dt><dd>
<p>
       Handle request to send back Ra to originating compartment.
</p></dd>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process messages from the scheduler objects. The Process should be called <span style="text-decoration:underline;">second</span> in each clock tick, after the Init message.The first entry in the shared msg is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt and so on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo. 
</p></dd>
<dt>init:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Init messages from the scheduler objects. Its job is to separate the compartmental calculations from the message passing. It doesn't really need to be shared, as it does not use the reinit part, but the scheduler objects expect this form of message for all scheduled output. The first entry is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt and so on. The second entry is a dummy MsgDest for the Reinit operation. It also uses ProcInfo. 
</p></dd>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message from a compartment to channels. The first entry is a MsgDest for the info coming from the channel. It expects Gk and Ek from the channel as args. The second entry is a MsgSrc sending Vm 
</p></dd>
<dt>axial:   <i>void</i></dt><dd>
<p>
       This is a shared message between asymmetric compartments. axial messages (this kind) connect up to raxial messages (defined below). The soma should use raxial messages to connect to the axial message of all the immediately adjacent dendritic compartments.This puts the (low) somatic resistance in series with these dendrites. Dendrites should then use raxial messages toconnect on to more distal dendrites. In other words, raxial messages should face outward from the soma. The first entry is a MsgSrc sending Vm to the axialFuncof the target compartment. The second entry is a MsgDest for the info coming from the other compt. It expects Ra and Vm from the other compt as args. Note that the message is named after the source type. 
</p></dd>
<dt>raxial:  <i>void</i></dt><dd>
<p>
       This is a raxial shared message between asymmetric compartments. The first entry is a MsgDest for the info coming from the other compt. It expects Vm from the other compt as an arg. The second is a MsgSrc sending Ra and Vm to the raxialFunc of the target compartment. 
</p></dd>
<dt>raxial1: <i>void</i></dt><dd>
<p>
       This is a raxial shared message between symmetric compartments.It goes from the tail of the current compartment to one closer to the soma.
</p></dd>
<dt>CONNECTTAIL:     <i>void</i></dt><dd>
<p>
       This is a raxial shared message between symmetric compartments.It is an alias for raxial1.
</p></dd>
<dt>raxial2: <i>void</i></dt><dd>
<p>
       This is a raxial2 shared message between symmetric compartments.It goes from the head of the current compartment to a compartment further away from the soma
</p></dd>
<dt>CONNECTHEAD:     <i>void</i></dt><dd>
<p>
       This is a raxial2 shared message between symmetric compartments.It is an alias for raxial2.It goes from the current compartment to one further from the soma
</p></dd>
<dt>CONNECTCROSS:    <i>void</i></dt><dd>
<p>
       This is a raxial2 shared message between symmetric compartments.It is an alias for raxial2.Conceptually, this goes from the tail of the current compartment to the tail of a sibling compartment. However,this works out to the same as CONNECTHEAD in terms of equivalentcircuit.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-82" class="outline-3">
<h3 id="sec-1-82"><span class="section-number-3">1.82</span> SynBase</h3>
<div class="outline-text-3" id="text-1-82">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>numSynapses:     <i>unsigned int</i></dt><dd>
<p>
       Number of synapses on SynBase
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-83" class="outline-3">
<h3 id="sec-1-83"><span class="section-number-3">1.83</span> SynChan</h3>
<div class="outline-text-3" id="text-1-83">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>numSynapses:     <i>unsigned int</i></dt><dd>
<p>
       Number of synapses on SynBase
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>tau1:    <i>double</i></dt><dd>
<p>
       Decay time constant for the synaptic conductance, tau1 &gt;= tau2.
</p></dd>
<dt>tau2:    <i>double</i></dt><dd>
<p>
       Rise time constant for the synaptic conductance, tau1 &gt;= tau2.
</p></dd>
<dt>normalizeWeights:        <i>bool</i></dt><dd>
<p>
       Flag. If true, the overall conductance is normalized by the number of individual synapses in this SynChan object.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>activation:      <i>double</i></dt><dd>
<p>
       Sometimes we want to continuously activate the channel
</p></dd>
<dt>modulator:       <i>double</i></dt><dd>
<p>
       Modulate channel response
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message to couple channel to compartment. The first entry is a MsgSrc to send Gk and Ek to the compartment The second entry is a MsgDest for Vm from the compartment.
</p></dd>
<dt>ghk:     <i>void</i></dt><dd>
<p>
       Message to Goldman-Hodgkin-Katz object
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message to receive Process message from scheduler
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-84" class="outline-3">
<h3 id="sec-1-84"><span class="section-number-3">1.84</span> SynChanBase</h3>
<div class="outline-text-3" id="text-1-84">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>numSynapses:     <i>unsigned int</i></dt><dd>
<p>
       Number of synapses on SynBase
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message to couple channel to compartment. The first entry is a MsgSrc to send Gk and Ek to the compartment The second entry is a MsgDest for Vm from the compartment.
</p></dd>
<dt>ghk:     <i>void</i></dt><dd>
<p>
       Message to Goldman-Hodgkin-Katz object
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-85" class="outline-3">
<h3 id="sec-1-85"><span class="section-number-3">1.85</span> Synapse</h3>
<div class="outline-text-3" id="text-1-85">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>weight:  <i>double</i></dt><dd>
<p>
       Synaptic weight
</p></dd>
<dt>delay:   <i>double</i></dt><dd>
<p>
       Axonal propagation delay to this synapse
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>addSpike:        <i>double</i></dt><dd>
<p>
       Handles arriving spike messages, by redirecting up to parent SynBase object
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-86" class="outline-3">
<h3 id="sec-1-86"><span class="section-number-3">1.86</span> Table</h3>
<div class="outline-text-3" id="text-1-86">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>vec:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       vector with all table entries
</p></dd>
<dt>outputValue:     <i>double</i></dt><dd>
<p>
       Output value holding current table entry or output of a calculation
</p></dd>
<dt>size:    <i>unsigned int</i></dt><dd>
<p>
       size of table. Note that this is the number of x divisions +1since it must represent the largest value as well as thesmallest
</p></dd>
<dt>threshold:       <i>double</i></dt><dd>
<p>
       threshold used when Table acts as a buffer for spikes
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>requestData:     <i>unsigned int</i></dt><dd>
<p>
       Sends request for a field to target object
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>linearTransform: <i>double,double</i></dt><dd>
<p>
       Linearly scales and offsets data. Scale first, then offset.
</p></dd>
<dt>xplot:   <i>string,string</i></dt><dd>
<p>
       Dumps table contents to xplot-format file. Argument 1 is filename, argument 2 is plotname
</p></dd>
<dt>plainPlot:       <i>string</i></dt><dd>
<p>
       Dumps table contents to single-column ascii file. Uses scientific notation. Argument 1 is filename
</p></dd>
<dt>loadCSV: <i>string,int,int,char</i></dt><dd>
<p>
       Reads a single column from a CSV file. Arguments: filename, column#, starting row#, separator
</p></dd>
<dt>loadXplot:       <i>string,string</i></dt><dd>
<p>
       Reads a single plot from an xplot file. Arguments: filename, plotnameWhen the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>loadXplotRange:  <i>string,string,unsigned int,unsigned int</i></dt><dd>
<p>
       Reads a single plot from an xplot file, and selects a subset of points from it. Arguments: filename, plotname, startindex, endindexUses C convention: startindex included, endindex not included.When the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>compareXplot:    <i>string,string,string</i></dt><dd>
<p>
       Reads a plot from an xplot file and compares with contents of TableBase.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: filename, plotname, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>compareVec:      <i>vector&lt;double&gt;,string</i></dt><dd>
<p>
       Compares contents of TableBase with a vector of doubles.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: Other vector, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>clearVec:        <i>void</i></dt><dd>
<p>
       Handles request to clear the data vector
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Fills data into the Table.
</p></dd>
<dt>spike:   <i>double</i></dt><dd>
<p>
       Fills spike timings into the Table. Signal has to exceed thresh
</p></dd>
<dt>recvData:        <i>bad</i></dt><dd>
<p>
       Handles data sent back following request
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call, updates internal time stamp.
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       Value of table at specified index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-87" class="outline-3">
<h3 id="sec-1-87"><span class="section-number-3">1.87</span> TableBase</h3>
<div class="outline-text-3" id="text-1-87">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>vec:     <i>vector&lt;double&gt;</i></dt><dd>
<p>
       vector with all table entries
</p></dd>
<dt>outputValue:     <i>double</i></dt><dd>
<p>
       Output value holding current table entry or output of a calculation
</p></dd>
<dt>size:    <i>unsigned int</i></dt><dd>
<p>
       size of table. Note that this is the number of x divisions +1since it must represent the largest value as well as thesmallest
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>linearTransform: <i>double,double</i></dt><dd>
<p>
       Linearly scales and offsets data. Scale first, then offset.
</p></dd>
<dt>xplot:   <i>string,string</i></dt><dd>
<p>
       Dumps table contents to xplot-format file. Argument 1 is filename, argument 2 is plotname
</p></dd>
<dt>plainPlot:       <i>string</i></dt><dd>
<p>
       Dumps table contents to single-column ascii file. Uses scientific notation. Argument 1 is filename
</p></dd>
<dt>loadCSV: <i>string,int,int,char</i></dt><dd>
<p>
       Reads a single column from a CSV file. Arguments: filename, column#, starting row#, separator
</p></dd>
<dt>loadXplot:       <i>string,string</i></dt><dd>
<p>
       Reads a single plot from an xplot file. Arguments: filename, plotnameWhen the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>loadXplotRange:  <i>string,string,unsigned int,unsigned int</i></dt><dd>
<p>
       Reads a single plot from an xplot file, and selects a subset of points from it. Arguments: filename, plotname, startindex, endindexUses C convention: startindex included, endindex not included.When the file has 2 columns, the 2nd column is loaded.
</p></dd>
<dt>compareXplot:    <i>string,string,string</i></dt><dd>
<p>
       Reads a plot from an xplot file and compares with contents of TableBase.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: filename, plotname, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>compareVec:      <i>vector&lt;double&gt;,string</i></dt><dd>
<p>
       Compares contents of TableBase with a vector of doubles.Result is put in 'output' field of table.If the comparison fails (e.g., due to zero entries), the return value is -1.Arguments: Other vector, comparison<sub>operationOperations</sub>: rmsd (for RMSDifference), rmsr (RMSratio ), dotp (Dot product, not yet implemented).
</p></dd>
<dt>clearVec:        <i>void</i></dt><dd>
<p>
       Handles request to clear the data vector
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       Value of table at specified index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-88" class="outline-3">
<h3 id="sec-1-88"><span class="section-number-3">1.88</span> TableEntry</h3>
<div class="outline-text-3" id="text-1-88">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>value:   <i>double</i></dt><dd>
<p>
       Data value in this entry
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-89" class="outline-3">
<h3 id="sec-1-89"><span class="section-number-3">1.89</span> Tick</h3>
<div class="outline-text-3" id="text-1-89">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>dt:      <i>double</i></dt><dd>
<p>
       Timestep for this tick
</p></dd>
<dt>localdt: <i>double</i></dt><dd>
<p>
       Timestep for this tick
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>process0:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 0
</p></dd>
<dt>reinit0: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 0
</p></dd>
<dt>process1:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 1
</p></dd>
<dt>reinit1: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 1
</p></dd>
<dt>process2:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 2
</p></dd>
<dt>reinit2: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 2
</p></dd>
<dt>process3:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 3
</p></dd>
<dt>reinit3: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 3
</p></dd>
<dt>process4:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 4
</p></dd>
<dt>reinit4: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 4
</p></dd>
<dt>process5:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 5
</p></dd>
<dt>reinit5: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 5
</p></dd>
<dt>process6:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 6
</p></dd>
<dt>reinit6: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 6
</p></dd>
<dt>process7:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 7
</p></dd>
<dt>reinit7: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 7
</p></dd>
<dt>process8:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 8
</p></dd>
<dt>reinit8: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 8
</p></dd>
<dt>process9:        <i>PK8ProcInfo</i></dt><dd>
<p>
       Process for Tick 9
</p></dd>
<dt>reinit9: <i>PK8ProcInfo</i></dt><dd>
<p>
       Reinit for Tick 9
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc0:   <i>void</i></dt><dd>
<p>
       Shared proc/reinit message
</p></dd>
<dt>proc1:   <i>void</i></dt><dd>
<p>
       Shared proc/reinit message
</p></dd>
<dt>proc2:   <i>void</i></dt><dd>
<p>
       Shared proc/reinit message
</p></dd>
<dt>proc3:   <i>void</i></dt><dd>
<p>
       Shared proc/reinit message
</p></dd>
<dt>proc4:   <i>void</i></dt><dd>
<p>
       Shared proc/reinit message
</p></dd>
<dt>proc5:   <i>void</i></dt><dd>
<p>
       Shared proc/reinit message
</p></dd>
<dt>proc6:   <i>void</i></dt><dd>
<p>
       Shared proc/reinit message
</p></dd>
<dt>proc7:   <i>void</i></dt><dd>
<p>
       Shared proc/reinit message
</p></dd>
<dt>proc8:   <i>void</i></dt><dd>
<p>
       Shared proc/reinit message
</p></dd>
<dt>proc9:   <i>void</i></dt><dd>
<p>
       Shared proc/reinit message
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-90" class="outline-3">
<h3 id="sec-1-90"><span class="section-number-3">1.90</span> TriPanel</h3>
<div class="outline-text-3" id="text-1-90">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>nPts:    <i>unsigned int</i></dt><dd>
<p>
       Number of points used by panel to specify geometry
</p></dd>
<dt>nDims:   <i>unsigned int</i></dt><dd>
<p>
       Number of Dimensions used by panel to specify geometry
</p></dd>
<dt>numNeighbors:    <i>unsigned int</i></dt><dd>
<p>
       Number of Neighbors of panel
</p></dd>
<dt>shapeId: <i>unsigned int</i></dt><dd>
<p>
       Identifier for shape type, as used by Smoldyn
</p></dd>
<dt>coords:  <i>vector&lt;double&gt;</i></dt><dd>
<p>
       All the coordinates for the panel. X vector, then Y, then ZZ can be left out for 2-D panels.Z and Y can be left out for 1-D panels.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toNeighbor:      <i>void</i></dt><dd>
<p>
       Identifies neighbors of the current panel
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>neighbor:        <i>void</i></dt><dd>
<p>
       Handles incoming message from neighbor
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>x:       <i>unsigned int,double</i></dt><dd>
<p>
       x coordinate identified by index
</p></dd>
<dt>y:       <i>unsigned int,double</i></dt><dd>
<p>
       y coordinate identified by index
</p></dd>
<dt>z:       <i>unsigned int,double</i></dt><dd>
<p>
       z coordinate identified by index
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-91" class="outline-3">
<h3 id="sec-1-91"><span class="section-number-3">1.91</span> VectorTable</h3>
<div class="outline-text-3" id="text-1-91">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>xdivs:   <i>unsigned int</i></dt><dd>
<p>
       Number of divisions.
</p></dd>
<dt>xmin:    <i>double</i></dt><dd>
<p>
       Minimum value in table.
</p></dd>
<dt>xmax:    <i>double</i></dt><dd>
<p>
       Maximum value in table.
</p></dd>
<dt>invdx:   <i>double</i></dt><dd>
<p>
       Maximum value in table.
</p></dd>
<dt>table:   <i>vector&lt;double&gt;</i></dt><dd>
<p>
       The lookup table.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
<dt>lookupvalue:     <i>double,double</i></dt><dd>
<p>
       Lookup function that performs interpolation to return a value.
</p></dd>
<dt>lookupindex:     <i>unsigned int,double</i></dt><dd>
<p>
       Lookup function that returns value by index.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-92" class="outline-3">
<h3 id="sec-1-92"><span class="section-number-3">1.92</span> ZombieBufPool</h3>
<div class="outline-text-3" id="text-1-92">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>reac:    <i>void</i></dt><dd>
<p>
       Connects to reaction
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p></dd>
<dt>species: <i>void</i></dt><dd>
<p>
       Shared message for connecting to species objects
</p></dd>
<dt>mesh:    <i>void</i></dt><dd>
<p>
       Shared message for dealing with mesh operations
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-93" class="outline-3">
<h3 id="sec-1-93"><span class="section-number-3">1.93</span> ZombieCaConc</h3>
<div class="outline-text-3" id="text-1-93">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Ca:      <i>double</i></dt><dd>
<p>
       Calcium concentration.
</p></dd>
<dt>CaBasal: <i>double</i></dt><dd>
<p>
       Basal Calcium concentration.
</p></dd>
<dt>Ca<sub>base</sub>: <i>double</i></dt><dd>
<p>
       Basal Calcium concentration, synonym for CaBasal
</p></dd>
<dt>tau:     <i>double</i></dt><dd>
<p>
       Settling time for Ca concentration
</p></dd>
<dt>B:       <i>double</i></dt><dd>
<p>
       Volume scaling factor
</p></dd>
<dt>thick:   <i>double</i></dt><dd>
<p>
       Thickness of Ca shell.
</p></dd>
<dt>ceiling: <i>double</i></dt><dd>
<p>
       Ceiling value for Ca concentration. If Ca &gt; ceiling, Ca = ceiling. If ceiling &lt;= 0.0, there is no upper limit on Ca concentration value.
</p></dd>
<dt>floor:   <i>double</i></dt><dd>
<p>
       Floor value for Ca concentration. If Ca &lt; floor, Ca = floor
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>concOut: <i>double</i></dt><dd>
<p>
       Concentration of Ca in pool
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>current: <i>double</i></dt><dd>
<p>
       Calcium Ion current, due to be converted to conc.
</p></dd>
<dt>currentFraction: <i>double,double</i></dt><dd>
<p>
       Fraction of total Ion current, that is carried by Ca2+.
</p></dd>
<dt>increase:        <i>double</i></dt><dd>
<p>
       Any input current that increases the concentration.
</p></dd>
<dt>decrease:        <i>double</i></dt><dd>
<p>
       Any input current that decreases the concentration.
</p></dd>
<dt>basal:   <i>double</i></dt><dd>
<p>
       Synonym for assignment of basal conc.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message to receive Process message from scheduler
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-94" class="outline-3">
<h3 id="sec-1-94"><span class="section-number-3">1.94</span> ZombieCompartment</h3>
<div class="outline-text-3" id="text-1-94">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       membrane potential
</p></dd>
<dt>Cm:      <i>double</i></dt><dd>
<p>
       Membrane capacitance
</p></dd>
<dt>Em:      <i>double</i></dt><dd>
<p>
       Resting membrane potential
</p></dd>
<dt>Im:      <i>double</i></dt><dd>
<p>
       Current going through membrane
</p></dd>
<dt>inject:  <i>double</i></dt><dd>
<p>
       Current injection to deliver into compartment
</p></dd>
<dt>initVm:  <i>double</i></dt><dd>
<p>
       Initial value for membrane potential
</p></dd>
<dt>Rm:      <i>double</i></dt><dd>
<p>
       Membrane resistance
</p></dd>
<dt>Ra:      <i>double</i></dt><dd>
<p>
       Axial resistance of compartment
</p></dd>
<dt>diameter:        <i>double</i></dt><dd>
<p>
       Diameter of compartment
</p></dd>
<dt>length:  <i>double</i></dt><dd>
<p>
       Length of compartment
</p></dd>
<dt>x0:      <i>double</i></dt><dd>
<p>
       X coordinate of start of compartment
</p></dd>
<dt>y0:      <i>double</i></dt><dd>
<p>
       Y coordinate of start of compartment
</p></dd>
<dt>z0:      <i>double</i></dt><dd>
<p>
       Z coordinate of start of compartment
</p></dd>
<dt>x:       <i>double</i></dt><dd>
<p>
       x coordinate of end of compartment
</p></dd>
<dt>y:       <i>double</i></dt><dd>
<p>
       y coordinate of end of compartment
</p></dd>
<dt>z:       <i>double</i></dt><dd>
<p>
       z coordinate of end of compartment
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>VmOut:   <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment on each timestep
</p></dd>
<dt>axialOut:        <i>double</i></dt><dd>
<p>
       Sends out Vm value of compartment to adjacent compartments,on each timestep
</p></dd>
<dt>raxialOut:       <i>double,double</i></dt><dd>
<p>
       Sends out Raxial information on each timestep, fields are Ra and Vm
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>randInject:      <i>double,double</i></dt><dd>
<p>
       Sends a random injection current to the compartment. Must beupdated each timestep.Arguments to randInject are probability and current.
</p></dd>
<dt>injectMsg:       <i>double</i></dt><dd>
<p>
       The injectMsg corresponds to the INJECT message in the GENESIS compartment. Unlike the 'inject' field, any value assigned by handleInject applies only for a single timestep.So it needs to be updated every dt for a steady (or varying)injection current
</p></dd>
<dt>cable:   <i>void</i></dt><dd>
<p>
       Message for organizing compartments into groups, calledcables. Doesn't do anything.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles 'process' call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles 'reinit' call
</p></dd>
<dt>initProc:        <i>void</i></dt><dd>
<p>
       Handles Process call for the 'init' phase of the Compartment calculations. These occur as a separate Tick cycle from the regular proc cycle, and should be called before the proc msg.
</p></dd>
<dt>initReinit:      <i>void</i></dt><dd>
<p>
       Handles Reinit call for the 'init' phase of the Compartment calculations.
</p></dd>
<dt>handleChannel:   <i>double,double</i></dt><dd>
<p>
       Handles conductance and Reversal potential arguments from Channel
</p></dd>
<dt>handleRaxial:    <i>double,double</i></dt><dd>
<p>
       Handles Raxial info: arguments are Ra and Vm.
</p></dd>
<dt>handleAxial:     <i>double</i></dt><dd>
<p>
       Handles Axial information. Argument is just Vm.
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process messages from the scheduler objects. The Process should be called <span style="text-decoration:underline;">second</span> in each clock tick, after the Init message.The first entry in the shared msg is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt and so on. The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo. 
</p></dd>
<dt>init:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Init messages from the scheduler objects. Its job is to separate the compartmental calculations from the message passing. It doesn't really need to be shared, as it does not use the reinit part, but the scheduler objects expect this form of message for all scheduled output. The first entry is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt and so on. The second entry is a dummy MsgDest for the Reinit operation. It also uses ProcInfo. 
</p></dd>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message from a compartment to channels. The first entry is a MsgDest for the info coming from the channel. It expects Gk and Ek from the channel as args. The second entry is a MsgSrc sending Vm 
</p></dd>
<dt>axial:   <i>void</i></dt><dd>
<p>
       This is a shared message between asymmetric compartments. axial messages (this kind) connect up to raxial messages (defined below). The soma should use raxial messages to connect to the axial message of all the immediately adjacent dendritic compartments.This puts the (low) somatic resistance in series with these dendrites. Dendrites should then use raxial messages toconnect on to more distal dendrites. In other words, raxial messages should face outward from the soma. The first entry is a MsgSrc sending Vm to the axialFuncof the target compartment. The second entry is a MsgDest for the info coming from the other compt. It expects Ra and Vm from the other compt as args. Note that the message is named after the source type. 
</p></dd>
<dt>raxial:  <i>void</i></dt><dd>
<p>
       This is a raxial shared message between asymmetric compartments. The first entry is a MsgDest for the info coming from the other compt. It expects Vm from the other compt as an arg. The second is a MsgSrc sending Ra and Vm to the raxialFunc of the target compartment. 
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-95" class="outline-3">
<h3 id="sec-1-95"><span class="section-number-3">1.95</span> ZombieEnz</h3>
<div class="outline-text-3" id="text-1-95">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p></dd>
<dt>k1:      <i>double</i></dt><dd>
<p>
       Forward reaction from enz + sub to complex
</p></dd>
<dt>k2:      <i>double</i></dt><dd>
<p>
       Reverse reaction from complex to enz + sub
</p></dd>
<dt>k3:      <i>double</i></dt><dd>
<p>
       Forward rate constant from complex to product + enz
</p></dd>
<dt>ratio:   <i>double</i></dt><dd>
<p>
       Ratio of k2/k3
</p></dd>
<dt>concK1:  <i>double</i></dt><dd>
<p>
       K1 expressed in concentration (1/millimolar.sec) units
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toEnz:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toCplx:  <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>cplxDest:        <i>double</i></dt><dd>
<p>
       Handles # of molecules of enz-sub complex
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>sub:     <i>void</i></dt><dd>
<p>
       Connects to substrate molecule
</p></dd>
<dt>prd:     <i>void</i></dt><dd>
<p>
       Connects to product molecule
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p></dd>
<dt>enz:     <i>void</i></dt><dd>
<p>
       Connects to enzyme pool
</p></dd>
<dt>cplx:    <i>void</i></dt><dd>
<p>
       Connects to enz-sub complex pool
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-96" class="outline-3">
<h3 id="sec-1-96"><span class="section-number-3">1.96</span> ZombieFuncPool</h3>
<div class="outline-text-3" id="text-1-96">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Handles input to control value of n_
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>reac:    <i>void</i></dt><dd>
<p>
       Connects to reaction
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p></dd>
<dt>species: <i>void</i></dt><dd>
<p>
       Shared message for connecting to species objects
</p></dd>
<dt>mesh:    <i>void</i></dt><dd>
<p>
       Shared message for dealing with mesh operations
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-97" class="outline-3">
<h3 id="sec-1-97"><span class="section-number-3">1.97</span> ZombieHHChannel</h3>
<div class="outline-text-3" id="text-1-97">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Gbar:    <i>double</i></dt><dd>
<p>
       Maximal channel conductance
</p></dd>
<dt>Ek:      <i>double</i></dt><dd>
<p>
       Reversal potential of channel
</p></dd>
<dt>Gk:      <i>double</i></dt><dd>
<p>
       Channel conductance variable
</p></dd>
<dt>Ik:      <i>double</i></dt><dd>
<p>
       Channel current variable
</p></dd>
<dt>Xpower:  <i>double</i></dt><dd>
<p>
       Power for X gate
</p></dd>
<dt>Ypower:  <i>double</i></dt><dd>
<p>
       Power for Y gate
</p></dd>
<dt>Zpower:  <i>double</i></dt><dd>
<p>
       Power for Z gate
</p></dd>
<dt>instant: <i>int</i></dt><dd>
<p>
       Bitmapped flag: bit 0 = Xgate, bit 1 = Ygate, bit 2 = ZgateWhen true, specifies that the lookup table value should beused directly as the state of the channel, rather than usedas a rate term for numerical integration for the state
</p></dd>
<dt>X:       <i>double</i></dt><dd>
<p>
       State variable for X gate
</p></dd>
<dt>Y:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p></dd>
<dt>Z:       <i>double</i></dt><dd>
<p>
       State variable for Y gate
</p></dd>
<dt>useConcentration:        <i>int</i></dt><dd>
<p>
       Flag: when true, use concentration message rather than Vm tocontrol Z gate
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>channelOut:      <i>double,double</i></dt><dd>
<p>
       Sends channel variables Gk and Ek to compartment
</p></dd>
<dt>permeability:    <i>double</i></dt><dd>
<p>
       Conductance term going out to GHK object
</p></dd>
<dt>IkOut:   <i>double</i></dt><dd>
<p>
       Channel current. This message typically goes to concenobjects that keep track of ion concentration.
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>Vm:      <i>double</i></dt><dd>
<p>
       Handles Vm message coming in from compartment
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>concen:  <i>double</i></dt><dd>
<p>
       Incoming message from Concen object to specific conc to usein the Z gate calculations
</p></dd>
<dt>createGate:      <i>string</i></dt><dd>
<p>
       Function to create specified gate.Argument: Gate type [X Y Z]
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>channel: <i>void</i></dt><dd>
<p>
       This is a shared message to couple channel to compartment. The first entry is a MsgSrc to send Gk and Ek to the compartment The second entry is a MsgDest for Vm from the compartment.
</p></dd>
<dt>ghk:     <i>void</i></dt><dd>
<p>
       Message to Goldman-Hodgkin-Katz object
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       This is a shared message to receive Process message from thescheduler. The first entry is a MsgDest for the Process operation. It has a single argument, ProcInfo, which holds lots of information about current time, thread, dt andso on.
        The second entry is a MsgDest for the Reinit operation. It also uses ProcInfo.
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-98" class="outline-3">
<h3 id="sec-1-98"><span class="section-number-3">1.98</span> ZombieMMenz</h3>
<div class="outline-text-3" id="text-1-98">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>Km:      <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in SI conc units (milliMolar)
</p></dd>
<dt>numKm:   <i>double</i></dt><dd>
<p>
       Michaelis-Menten constant in number units, volume dependent
</p></dd>
<dt>kcat:    <i>double</i></dt><dd>
<p>
       Forward rate constant for enzyme, units 1/sec
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates in this MM reaction. Usually 1.Does not include the enzyme itself
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>enzDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of Enzyme
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product. Dummy.
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the MMEnz to recompute its numKm after remeshing
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>sub:     <i>void</i></dt><dd>
<p>
       Connects to substrate molecule
</p></dd>
<dt>prd:     <i>void</i></dt><dd>
<p>
       Connects to product molecule
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-99" class="outline-3">
<h3 id="sec-1-99"><span class="section-number-3">1.99</span> ZombiePool</h3>
<div class="outline-text-3" id="text-1-99">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>n:       <i>double</i></dt><dd>
<p>
       Number of molecules in pool
</p></dd>
<dt>nInit:   <i>double</i></dt><dd>
<p>
       Initial value of number of molecules in pool
</p></dd>
<dt>diffConst:       <i>double</i></dt><dd>
<p>
       Diffusion constant of molecule
</p></dd>
<dt>conc:    <i>double</i></dt><dd>
<p>
       Concentration of molecules in this pool
</p></dd>
<dt>concInit:        <i>double</i></dt><dd>
<p>
       Initial value of molecular concentration in pool
</p></dd>
<dt>size:    <i>double</i></dt><dd>
<p>
       Size of compartment. Units are SI. Utility field, the actual size info is stored on a volume mesh entry in the parent compartment.This is hooked up by a message. If the message isn'tavailable size is just taken as 1
</p></dd>
<dt>speciesId:       <i>unsigned int</i></dt><dd>
<p>
       Species identifier for this mol pool. Eventually link to ontology.
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>nOut:    <i>double</i></dt><dd>
<p>
       Sends out # of molecules in pool on each timestep
</p></dd>
<dt>requestMolWt:    <i>void</i></dt><dd>
<p>
       Requests Species object for mol wt
</p></dd>
<dt>requestSize:     <i>double</i></dt><dd>
<p>
       Requests Size of pool from matching mesh entry
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>group:   <i>void</i></dt><dd>
<p>
       Handle for grouping. Doesn't do anything.
</p></dd>
<dt>reacDest:        <i>double,double</i></dt><dd>
<p>
       Handles reaction input
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>handleMolWt:     <i>double</i></dt><dd>
<p>
       Separate finfo to assign molWt, and consequently diffusion const.Should only be used in SharedMsg with species.
</p></dd>
<dt>remesh:  <i>double,unsigned int,unsigned int,vector&lt;unsigned int&gt;,vector&lt;double&gt;</i></dt><dd>
<p>
       Handle commands to remesh the pool. This may involve changing the number of pool entries, as well as changing their volumes
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>reac:    <i>void</i></dt><dd>
<p>
       Connects to reaction
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p></dd>
<dt>species: <i>void</i></dt><dd>
<p>
       Shared message for connecting to species objects
</p></dd>
<dt>mesh:    <i>void</i></dt><dd>
<p>
       Shared message for dealing with mesh operations
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-100" class="outline-3">
<h3 id="sec-1-100"><span class="section-number-3">1.100</span> ZombieReac</h3>
<div class="outline-text-3" id="text-1-100">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in # units
</p></dd>
<dt>kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in # units
</p></dd>
<dt>Kf:      <i>double</i></dt><dd>
<p>
       Forward rate constant, in concentration units
</p></dd>
<dt>Kb:      <i>double</i></dt><dd>
<p>
       Reverse rate constant, in concentration units
</p></dd>
<dt>numSubstrates:   <i>unsigned int</i></dt><dd>
<p>
       Number of substrates of reaction
</p></dd>
<dt>numProducts:     <i>unsigned int</i></dt><dd>
<p>
       Number of products of reaction
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>toSub:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p></dd>
<dt>toPrd:   <i>double,double</i></dt><dd>
<p>
       Sends out increment of molecules on product each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>subDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of substrate
</p></dd>
<dt>prdDest: <i>double</i></dt><dd>
<p>
       Handles # of molecules of product
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p></dd>
<dt>remesh:  <i>void</i></dt><dd>
<p>
       Tells the reac to recompute its numRates, as remeshing has happened
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>sub:     <i>void</i></dt><dd>
<p>
       Connects to substrate pool
</p></dd>
<dt>prd:     <i>void</i></dt><dd>
<p>
       Connects to substrate pool
</p></dd>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-101" class="outline-3">
<h3 id="sec-1-101"><span class="section-number-3">1.101</span> ZombieSumFunc</h3>
<div class="outline-text-3" id="text-1-101">


<ul>
<li><b>Value field</b>
<dl>
<dt>this:    <i>Neutral</i></dt><dd>
<p>
       Access function for entire object
</p></dd>
<dt>name:    <i>string</i></dt><dd>
<p>
       Name of object
</p></dd>
<dt>me:      <i>ObjId</i></dt><dd>
<p>
       ObjId for current object
</p></dd>
<dt>parent:  <i>ObjId</i></dt><dd>
<p>
       Parent ObjId for current object
</p></dd>
<dt>children:        <i>vector&lt;Id&gt;</i></dt><dd>
<p>
       vector of ObjIds listing all children of current object
</p></dd>
<dt>path:    <i>string</i></dt><dd>
<p>
       text path for object
</p></dd>
<dt>class:   <i>string</i></dt><dd>
<p>
       Class Name of object
</p></dd>
<dt>linearSize:      <i>unsigned int</i></dt><dd>
<p>
       # of entries on Element: product of all dimensions.Note that on a FieldElement this includes field entries.If field entries form a ragged array, then the linearSize may begreater than the actual number of allocated entries, since thelastDimension is at least as big as the largest ragged array.
</p></dd>
<dt>objectDimensions:        <i>vector&lt;unsigned int&gt;</i></dt><dd>
<p>
       Array Dimensions of object on the Element.This includes the lastDimension (field dimension) if present.
</p></dd>
<dt>lastDimension:   <i>unsigned int</i></dt><dd>
<p>
       Max size of the last dimension of the object.In the case of regular objects, resizing this value resizesthe last dimensionIn the case of ragged arrays (such as synapses), resizing thisvalue resizes the upper limit of the last dimension,but cannot make it smaller than the biggest ragged array size.Normally is only assigned from <a href="#Shell-doSyncDataHandler">Shell::doSyncDataHandler</a>.
</p></dd>
<dt>localNumField:   <i>unsigned int</i></dt><dd>
<p>
       For a FieldElement: number of entries of self on current nodeFor a regular Element: zero.
</p></dd>
<dt>pathIndices:     <i>vector&lt; vector&lt;unsigned int&gt; &gt;</i></dt><dd>
<p>
       Indices of the entire path hierarchy leading up to this Object.
</p></dd>
<dt>msgOut:  <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages going out from this Element
</p></dd>
<dt>msgIn:   <i>vector&lt;ObjId&gt;</i></dt><dd>
<p>
       Messages coming in to this Element
</p></dd>
<dt>result:  <i>double</i></dt><dd>
<p>
       outcome of summation
</p>
</dd>
</dl>

</li>
<li><b>Source message field</b>
<dl>
<dt>childMsg:        <i>int</i></dt><dd>
<p>
       Message to child Elements
</p></dd>
<dt>output:  <i>double</i></dt><dd>
<p>
       Sends out sum on each timestep
</p>
</dd>
</dl>

</li>
<li><b>Destination message field</b>
<dl>
<dt>parentMsg:       <i>int</i></dt><dd>
<p>
       Message from Parent Element(s)
</p></dd>
<dt>input:   <i>double</i></dt><dd>
<p>
       Handles input values
</p></dd>
<dt>process: <i>void</i></dt><dd>
<p>
       Handles process call
</p></dd>
<dt>reinit:  <i>void</i></dt><dd>
<p>
       Handles reinit call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>
<dl>
<dt>proc:    <i>void</i></dt><dd>
<p>
       Shared message for process and reinit
</p>
</dd>
</dl>

</li>
<li><b>Lookup field</b>
<dl>
<dt>neighbours:      <i>string,vector&lt;Id&gt;</i></dt><dd>
<p>
       Ids of Elements connected this Element on specified field.
</p></dd>
</dl>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-102" class="outline-3">
<h3 id="sec-1-102"><span class="section-number-3">1.102</span> testSched</h3>
<div class="outline-text-3" id="text-1-102">


<ul>
<li><b>Value field</b>

</li>
<li><b>Source message field</b>

</li>
<li><b>Destination message field</b>
<dl>
<dt>process: <i>void</i></dt><dd>
<p>
       handles process call
</p>
</dd>
</dl>

</li>
<li><b>Shared message field</b>

</li>
<li><b>Lookup field</b>
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> MOOSE Functions</h2>
<div class="outline-text-2" id="text-2">




</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> ce</h3>
<div class="outline-text-3" id="text-2-1">

<p>   Set the current working element. 'ce' is an alias of this function
</p>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> connect</h3>
<div class="outline-text-3" id="text-2-2">

<p>   connect(src, src<sub>field</sub>, dest, dest<sub>field</sub>, message<sub>type</sub>) -&gt; bool
</p>
<p>   
   Create a message between `src<sub>field`</sub> on `src` object to `dest<sub>field`</sub>
   on `dest` object.
</p>
<p>   
   Parameters

</p>
<hr/>
<p>
   src : element
           the source object
   src<sub>field</sub> : str
           the source field name. Fields listed under `srcFinfo` and
   `sharedFinfo` qualify for this.
   dest : element
           the destination object.
   dest<sub>field</sub> : str
           the destination field name. Fields listed under `destFinfo`
   and `sharedFinfo` qualify for this.
   message<sub>type</sub> : str (optional)
           Type of the message. Can be `Single`, `OneToOne`, `OneToAll`.
   If not specified, it defaults to `Single`.
</p>
<p>   
   Returns

</p>
<hr/>
<p>
   element of the message-manager for the newly created message.
</p>
<p>   
   Example

</p>
<hr/>
<p>
   Connect the output of a pulse generator to the input of a spike
   generator:
</p>
<p>   
   &gt;&gt;&gt; pulsegen = moose.PulseGen('pulsegen')
   &gt;&gt;&gt; spikegen = moose.SpikeGen('spikegen')
   &gt;&gt;&gt; moose.connect(pulsegen, 'outputOut', spikegen, 'Vm')
   1
</p>
</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> copy</h3>
<div class="outline-text-3" id="text-2-3">

<p>   copy(src, dest, name, n, toGlobal, copyExtMsg) -&gt; bool
   Make copies of a moose object.
   Parameters

</p>
<hr/>
<p>
   src : ematrix, element or str
           source object.
   dest : ematrix, element or str
           Destination object to copy into.
   name : str
           Name of the new object. If omitted, name of the original will be used.
   n : int
           Number of copies to make.
   toGlobal: int
           Relevant for parallel environments only. If false, the copies will
   reside on local node, otherwise all nodes get the copies.
   copyExtMsg: int
           If true, messages to/from external objects are also copied.
</p>
<p>   
   Returns

</p>
<hr/>
<p>
   ematrix of the copied object
</p>
</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> delete</h3>
<div class="outline-text-3" id="text-2-4">

<p>   moose.delete(id)
</p>
<p>   
   Delete the underlying moose object. This does not delete any of the
   Python objects referring to this ematrix but does invalidate them. Any
   attempt to access them will raise a ValueError.
</p>
<p>   
   Parameters
</p>

<hr/>
<p>
   id : ematrix
           ematrix of the object to be deleted.
</p>
</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> element</h3>
<div class="outline-text-3" id="text-2-5">

<p>   moose.element(arg) -&gt; moose object
</p>
<p>   
   Convert a path or an object to the appropriate builtin moose class
   instance
   Parameters

</p>
<hr/>
<p>
   arg: str or ematrix or moose object
   path of the moose element to be converted or another element (possibly
   available as a superclass instance).
</p>
<p>   
   Returns
   An element of the moose builtin class the specified object belongs
   to.
</p>
</div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> exists</h3>
<div class="outline-text-3" id="text-2-6">

<p>   True if there is an object with specified path.
</p>
</div>

</div>

<div id="outline-container-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> getCwe</h3>
<div class="outline-text-3" id="text-2-7">

<p>   Get the current working element. 'pwe' is an alias of this function.
</p>
</div>

</div>

<div id="outline-container-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> getField</h3>
<div class="outline-text-3" id="text-2-8">

<p>   getField(element, field, fieldtype) &ndash; Get specified field of specified type from object ematrix.
</p>
</div>

</div>

<div id="outline-container-2-9" class="outline-3">
<h3 id="sec-2-9"><span class="section-number-3">2.9</span> getFieldDict</h3>
<div class="outline-text-3" id="text-2-9">

<p>   getFieldDict(className, finfoType) -&gt; dict
</p>
<p>   
   Get dictionary of field names and types for specified class.
   Parameters

</p>
<hr/>
<p>
   className : str
           MOOSE class to find the fields of.
   finfoType : str (optional)
           Finfo type of the fields to find. If empty or not specified, all
   fields will be retrieved.
   note: This behaviour is different from `getFieldNames` where only
   `valueFinfo`s are returned when `finfoType` remains unspecified.
</p>
<p>   
   Example

</p>
<hr/>
<p>
   List all the source fields on class Neutral:
   &gt;&gt;&gt; moose.getFieldDict('Neutral', 'srcFinfo')
   {'childMsg': 'int'}
</p>
</div>

</div>

<div id="outline-container-2-10" class="outline-3">
<h3 id="sec-2-10"><span class="section-number-3">2.10</span> getFieldNames</h3>
<div class="outline-text-3" id="text-2-10">

<p>   getFieldNames(className, finfoType='valueFinfo') -&gt; tuple
</p>
<p>   
   Get a tuple containing the name of all the fields of `finfoType`
   kind.
</p>
<p>   
   Parameters

</p>
<hr/>
<p>
   className : string
           Name of the class to look up.
   finfoType : string
           The kind of field (`valueFinfo`, `srcFinfo`, `destFinfo`,
   `lookupFinfo`, `fieldElementFinfo`.).
</p>
</div>

</div>

<div id="outline-container-2-11" class="outline-3">
<h3 id="sec-2-11"><span class="section-number-3">2.11</span> isRunning</h3>
<div class="outline-text-3" id="text-2-11">

<p>   True if the simulation is currently running.
</p>
</div>

</div>

<div id="outline-container-2-12" class="outline-3">
<h3 id="sec-2-12"><span class="section-number-3">2.12</span> loadModel</h3>
<div class="outline-text-3" id="text-2-12">

<p>   loadModel(filename, modelpath, solverclass) -&gt; moose.ematrix
</p>
<p>   
   Load model from a file to a specified path.
</p>

<p>   
   Parameters

</p>
<hr/>
<p>
   filename : str
           model description file.
   modelpath : str
           moose path for the top level element of the model to be created.
           solverclass : str
           (optional) solver type to be used for simulating the model.
</p>
<p>   
   Returns

</p>
<hr/>
<p>
   ematrix instance refering to the loaded model container.
</p>
</div>

</div>

<div id="outline-container-2-13" class="outline-3">
<h3 id="sec-2-13"><span class="section-number-3">2.13</span> move</h3>
<div class="outline-text-3" id="text-2-13">

<p>   Move a ematrix object to a destination.
</p>
</div>

</div>

<div id="outline-container-2-14" class="outline-3">
<h3 id="sec-2-14"><span class="section-number-3">2.14</span> quit</h3>
<div class="outline-text-3" id="text-2-14">

<p>   Finalize MOOSE threads and quit MOOSE. This is made available for debugging purpose only. It will automatically get called when moose module is unloaded. End user should not use this function.
</p>
</div>

</div>

<div id="outline-container-2-15" class="outline-3">
<h3 id="sec-2-15"><span class="section-number-3">2.15</span> reinit</h3>
<div class="outline-text-3" id="text-2-15">

<p>   reinit() -&gt; None
</p>
<p>   
   Reinitialize simulation.
</p>
<p>   
   This function (re)initializes moose simulation. It must be called
   before you start the simulation (see moose.start). If you want to
   continue simulation after you have called moose.reinit() and
   moose.start(), you must NOT call moose.reinit() again. Calling
   moose.reinit() again will take the system back to initial setting
   (like clear out all data recording tables, set state variables to
   their initial values, etc.
</p>
</div>

</div>

<div id="outline-container-2-16" class="outline-3">
<h3 id="sec-2-16"><span class="section-number-3">2.16</span> saveModel</h3>
<div class="outline-text-3" id="text-2-16">

<p>   saveModel(source, fileame)
</p>
<p>   
   Save model rooted at `source` to file `filename`.
</p>

<p>   
   Parameters

</p>
<hr/>
<p>
   source: ematrix or element or str
           root of the model tree
</p>
<p>   
   filename: str
           destination file to save the model in.
</p>
<p>   
   Returns

</p>
<hr/>
<p>
   None
</p>
</div>

</div>

<div id="outline-container-2-17" class="outline-3">
<h3 id="sec-2-17"><span class="section-number-3">2.17</span> seed</h3>
<div class="outline-text-3" id="text-2-17">

<p>   moose.seed(seedvalue) -&gt; None
</p>
<p>   
   Reseed MOOSE random number generator.
</p>

<p>   
   Parameters

</p>
<hr/>
<p>
   seed: int
           Optional value to use for seeding. If 0, a random seed is
           automatically created using the current system time and other
           information. If not specified, it defaults to 0.
</p>
</div>

</div>

<div id="outline-container-2-18" class="outline-3">
<h3 id="sec-2-18"><span class="section-number-3">2.18</span> setClock</h3>
<div class="outline-text-3" id="text-2-18">

<p>   Set the dt of a clock.
</p>
</div>

</div>

<div id="outline-container-2-19" class="outline-3">
<h3 id="sec-2-19"><span class="section-number-3">2.19</span> setCwe</h3>
<div class="outline-text-3" id="text-2-19">

<p>   Set the current working element. 'ce' is an alias of this function
</p>
</div>

</div>

<div id="outline-container-2-20" class="outline-3">
<h3 id="sec-2-20"><span class="section-number-3">2.20</span> start</h3>
<div class="outline-text-3" id="text-2-20">

<p>   start(t) -&gt; None
</p>
<p>   
   Run simulation for `t` time. Advances the simulator clock by `t`
   time.
</p>
<p>   
   After setting up a simulation, YOU MUST CALL MOOSE.REINIT() before
   CALLING MOOSE.START() TO EXECUTE THE SIMULATION. Otherwise, the
   simulator behaviour will be undefined. Once moose.reinit() has been
   called, you can call moose.start(t) as many time as you like. This
   will continue the simulation from the last state for `t` time.
</p>

<p>   
   Parameters

</p>
<hr/>
<p>
   t : float
           duration of simulation.
</p>
<p>   
   Returns

</p>
<hr/>
<p>
           None
</p>
<p>   
   See also

</p>
<hr/>
<p>
   moose.reinit : (Re)initialize simulation
</p>
</div>

</div>

<div id="outline-container-2-21" class="outline-3">
<h3 id="sec-2-21"><span class="section-number-3">2.21</span> stop</h3>
<div class="outline-text-3" id="text-2-21">

<p>   Stop simulation
</p>
</div>

</div>

<div id="outline-container-2-22" class="outline-3">
<h3 id="sec-2-22"><span class="section-number-3">2.22</span> useClock</h3>
<div class="outline-text-3" id="text-2-22">

<p>   Schedule objects on a specified clock
</p>
</div>

</div>

<div id="outline-container-2-23" class="outline-3">
<h3 id="sec-2-23"><span class="section-number-3">2.23</span> wildcardFind</h3>
<div class="outline-text-3" id="text-2-23">

<p>   moose.wildcardFind(expression) -&gt; tuple of ematrices.
</p>
<p>   
   Find an object by wildcard.
</p>

<p>   
   Parameters

</p>
<hr/>
<p>
   expression: str
           MOOSE allows wildcard expressions of the form
           {PATH}/{WILDCARD}[{CONDITION}]
           where {PATH} is valid path in the element tree.
           {WILDCARD} can be `#` or `##`.
           `#` causes the search to be restricted to the children of the
           element specified by {PATH}.
           `##` makes the search to recursively go through all the descendants
           of the {PATH} element.
           {CONDITION} can be
           TYPE={CLASSNAME} : an element satisfies this condition if it is of
           class {CLASSNAME}.
           ISA={CLASSNAME} : alias for TYPE={CLASSNAME}
           CLASS={CLASSNAME} : alias for TYPE={CLASSNAME}
           FIELD({FIELDNAME}){OPERATOR}{VALUE} : compare field {FIELDNAME} with
           {VALUE} by {OPERATOR} where {OPERATOR} is a comparison operator (=,
           !=, &gt;, &lt;, &gt;=, &lt;=).
           For example, /mymodel/##[FIELD(Vm)&gt;=-65] will return a list of all
           the objects under /mymodel whose Vm field is &gt;= -65.
</p>
</div>

</div>

<div id="outline-container-2-24" class="outline-3">
<h3 id="sec-2-24"><span class="section-number-3">2.24</span> writeSBML</h3>
<div class="outline-text-3" id="text-2-24">

<p>   Export biochemical model to an SBML file.
</p>
</div>

</div>

<div id="outline-container-2-25" class="outline-3">
<h3 id="sec-2-25"><span class="section-number-3">2.25</span> doc</h3>
<div class="outline-text-3" id="text-2-25">

<p>   Display the documentation for class or field in a class.
</p>
<p>   
   Parameters

</p>
<hr/>
<p>
   arg: str or moose class or instance of melement or instance of ematrix
</p>
<p>   
   argument can be a string specifying a moose class name and a field
   name separated by a dot. e.g., 'Neutral.name'. Prepending `moose.`
   is allowed. Thus moose.doc('moose.Neutral.name') is equivalent to
   the above.
</p>
<p>   
   argument can also be string specifying just a moose class name or
   a moose class or a moose object (instance of melement or ematrix
   or there subclasses). In that case, the builtin documentation for
   the corresponding moose class is displayed.
</p>
<p>   
   paged: bool
</p>
<p>   
   Whether to display the docs via builtin pager or print and
   exit. If not specified, it defaults to False and moose.doc(xyz)
   will print help on xyz and return control to command line.
</p>
</div>

</div>

<div id="outline-container-2-26" class="outline-3">
<h3 id="sec-2-26"><span class="section-number-3">2.26</span> getfielddoc</h3>
<div class="outline-text-3" id="text-2-26">

<p>   Get the documentation for field specified by
   tokens.
</p>
<p>   
   tokens should be a two element list/tuple where first element is a
   MOOSE class name and second is the field name.
</p>
</div>

</div>

<div id="outline-container-2-27" class="outline-3">
<h3 id="sec-2-27"><span class="section-number-3">2.27</span> getmoosedoc</h3>
<div class="outline-text-3" id="text-2-27">

<p>   Retrieve MOOSE builtin documentation for tokens.
</p>
<p>   
   tokens is a list or tuple containing: (classname, [fieldname])
</p>
</div>

</div>

<div id="outline-container-2-28" class="outline-3">
<h3 id="sec-2-28"><span class="section-number-3">2.28</span> le</h3>
<div class="outline-text-3" id="text-2-28">

<p>   List elements. 
</p>
<p>   
   Parameters

</p>
<hr/>
<p>
   el: str/melement/ematrix/None
   The element or the path under which to look. If `None`, children
   of current working element are displayed.
</p>
</div>

</div>

<div id="outline-container-2-29" class="outline-3">
<h3 id="sec-2-29"><span class="section-number-3">2.29</span> listmsg</h3>
<div class="outline-text-3" id="text-2-29">

<p>   Return a list containing the incoming and outgoing messages of
   the given object.
</p>
</div>

</div>

<div id="outline-container-2-30" class="outline-3">
<h3 id="sec-2-30"><span class="section-number-3">2.30</span> pwe</h3>
<div class="outline-text-3" id="text-2-30">

<p>   Print present working element. Convenience function for GENESIS
   users.
</p>
</div>

</div>

<div id="outline-container-2-31" class="outline-3">
<h3 id="sec-2-31"><span class="section-number-3">2.31</span> showfield</h3>
<div class="outline-text-3" id="text-2-31">

<p>   Show the fields of the element, their data types and values in
   human readable format. Convenience function for GENESIS users.
</p>
<p>   
   Parameters:
</p>
<p>   
   elem: str/melement instance
   Element or path of an existing element.
</p>
<p>   
   field: str
   Field to be displayed. If '*', all fields are displayed.
</p>
<p>   
   showtype: bool
   If True show the data type of each field.
</p>
</div>

</div>

<div id="outline-container-2-32" class="outline-3">
<h3 id="sec-2-32"><span class="section-number-3">2.32</span> showfields</h3>
<div class="outline-text-3" id="text-2-32">

<p>   Convenience function. Should be deprecated if nobody uses it.
</p>
</div>

</div>

<div id="outline-container-2-33" class="outline-3">
<h3 id="sec-2-33"><span class="section-number-3">2.33</span> showmsg</h3>
<div class="outline-text-3" id="text-2-33">

<p>   Prints the incoming and outgoing messages of the given object.
</p>
</div>

</div>

<div id="outline-container-2-34" class="outline-3">
<h3 id="sec-2-34"><span class="section-number-3">2.34</span> syncDataHandler</h3>
<div class="outline-text-3" id="text-2-34">

<p>   Synchronize data handlers for target.
</p>
<p>   
   Parameter:
   target &ndash; target element or path or ematrix.
</p></div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-10-04 20:12:08 IST</p>
<p class="author">Author: Automatically extracted on 2012-10-04T20:11:55.291611</p>
<p class="creator">Org version 7.8.11 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
