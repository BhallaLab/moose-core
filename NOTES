26 Dec 2006

Revision 50: Implemented connects and disconnects at the conn level. This
is non-trivial as it involves updating ranges and target Conns affected by
the index changes.

- Handle Element deletion. Do it intelligently: first mark all elements
	scheduled for deletion, then efficiently update only the surviving
	connections.
	This is a bit premature as we also need to delete the MsgSrc/MsgDest
	entries along with this.

- Build up MsgSrc and MsgDest handling

- Test regular messages

=============================================================================
29 Dec 2006

Revision 51: checked in the preliminary element deletion stuff prior to
going on with the MsgSrc stuff.

=============================================================================
30 Dec 2006

Message creation starting to take shape. For shared messages we have
to go to the first src _on both sides_, and ask this src to insert a new
Conn which is then used to make a connection. If the shared message only
has dests then the dest takes care of the Conn insertion. For regular
messages it is straightforward: insert Conn on src and dest respectively.

Also have a flow chart for how to set up the messages from the view point of
the Field/finfo:

typedef FuncList vector< RecvFunc >

addFrom:
- Check respondToAdd. This returns a conn index if it works
- Trigger a local event for message formation.
- Insert new Conn on src as above
- Tie up Conns.

bool respondToAdd( Field src, FuncList& srcRf, vector< Ftype* >& srcType,
	FuncList& destRF, unsigned int& destConn )
- Check the types
- Trigger a local event for message formation.
- inert the new Conn, using a src if there are any funcs coming in.
- Return with the new Conn and recvfuncs.

delete
- Most of the effort goes into identifying the conns to go for.
- Delete the conn
- Do local event.

set/call
- Check arg type(s)
- Make dummy conn
- execute all RFs in FuncList.

get
- For values:
	- Copy values into pointer
- For MsgSrc:
	- Copy target list
- msgDest
	- Copy target list.

strSet
- Convert arg type(s)
- Do above set/call

strGet
- Do above get
- Convert arg types into string.

Finally got initial pass at messaging to compile, though it croaks when run.
=============================================================================
31 Dec 2006

Setting up to make messages using MsgSrc and MsgDest.
Got initial message creation to work. 
Looks like we could simplify MsgDests to be independent of ranges, and 
refer directly to ranges in the Conn vector.

Checked in as revision 53.

Trying now to do send.
OK, got it to work. But the send is a horribly messy function, way too many
indirections. Need to rethink the structure of MsgSrc and MsgDest, try to 
do away with the Range altogether.
Anyway, check this version in as revision 54.

Working on update. Looks like it will be good. But currently the updates
are a bit messy. Not wrapped up.
Could even consider putting in pointers to the Conn entries in the Src
vector. Would need to do a bit of extra work on some updates, but the
Sends would be slightly faster as they would not have to lookup values.
=============================================================================
1 Jan 2007
After much grinding, finally reimplemented the messaging starting from the
definition of MsgSrc to get rid of the Range. Compiles. Fails.

Various fixes later. Compiles, runs.

Checked in as revision 55.

Now to do more thorough checking
+ Conn insertion and updates in later sections.
+ src link list
+ Managing both dests and srcs as if in a shared message.
+ Conn deleting


=============================================================================
2 Jan 2007
Working on the checks listed above. Minor fixes.
Lots more tests added, all clear. Time to check it in.

=============================================================================
3 Jan 2007
Design the infos now. Operations to support:

Admin:
match ( to find info from string, and possibly subfields or array entries )
isA (type identity, going through Ftype)

Messaging:
add ( as source )
respondToAdd (as dest )
drop (as any half of connection )
respondToDrop ( as other half )
srcList
destList

Data:
set/call ( using usual recvfunc )
get
strset
strget

The Element itself has to manage an array of finfos, which are set up
using a static initializer. Each finfo must have
RecvFunc ( This provides the set operation )
getFunc ( for messages this is an indexed list of targets. But doesn't match
	RecvFunc )
Ftype ( handles str conversions either way, does type checking )
base class info (needed to handle nested fields)
Would like to also finfos to contain cinfos. finfo_[0] has class info of
	data ptr as a whole.
	Field finfos are derived from cinfos for other classes, so that 
	every field has full class mappings.
	Perhaps Ftype === cinfo? But we have multi-arg recvfuncs.


I had a proliferation of ~20 Finfos, all listed:

What is a finfo?
- Something you send messages to or from.
- Something to manage and access data fields

The first is more restrictive. More stuff is needed for data fields.


=============================================================================
4 Jan 2007

Relay stuff for finfos:

All srcs can be dests: Provide a RecvFunc that is templated to pass arguments
from the triggering function directly to the src. Can use send and sendTo, 
but sendBack is tricky.
	- This means that we can configure fields to do this cleanly, except
	that here the RecvFunc is munged so it instead uses the field value.

All dests can be srcs passing the same arguments:
Here we just need to go back to the real src and have it send another message.
No additional stuff in the finfo.

In the earlier version we had some 20 Finfo types. Here we need:
- ObjFinfo: Uses a lookup func, permits nesting, 
	permits full object assignment, passes a pointer except at postmaster.
- ValueFinfo: No nesting. provides recvFunc for set. Use another recvFunc to
	trigger return message, which is also used for get. Perhaps split it?
	Actually respondToAdd is a good way to provide different recvFuncs.
- MsgSrcFinfo: No nesting. provides recvFunc for passing arguments right into
	src.  Handles specific MsgSrc entries.
- MsgDestFinfo: No nesting. Provides recvFunc for operations.
- SharedFinfo: No nesting. Provides a whole set of recvFuncs. Or sometimes
	no recvfuncs if it is only srcs.

Options for getting values from fields:
- Use a getfunc
	- Simple.
	- Still need to implement something for message access.
- Using a shared message with a trigger and a return msgsrc 
	- Complex. For regular object assignment would need something like
	a temporary message to be set up. If this could be simplified it would
	be OK.
		- Get the trigger recvfunc with a respondToAdd. Perhaps at
		this point the target can decide which recvfunc to return,
		one for gets, or one for proper messages.
		- Calling a trigger recvfunc is easy.
		- Need to provide a return conn in any case, because that is
		how recvfuncs work. In addition would need to have a recvFunc
		to accept the return value. 
			- Pass the rf in the triggering recvFunc? 
			Not good, specially across nodes.
			- Assume a generic recvfunc that just typecasts the
			e->data and assigns it? Works, except how do we give
			it other recvfuncs when we set up proper messages.
			- Actually, simple: Just pass in the required return
			recvfunc in the respondToAdd itself. But oops, where
			does it store it? The proper message stores it in 
			the MsgSrc array.
			- Make a distinction in the respondToAdd about which
			recvfunc to return to the caller. If there is no
			passed in recvfunc, return the recvfunc that typecasts
			e->data.
	- Works for message access
	- Would it be simpler for cross-node field access?
- Build a full message and then delete it.
	- Major complex to execute, but simplest to program.
	- Residual allocations all over the place.
	- Completely general across nodes
		- Issue with deadlocks and timings across nodes. These are
		there in the other methods too unless we do the serializing.
- Return a recvfunc void(*)(Conn*, value& ret) where we return the value
	in a naughty way.
- Pass in a recvfunc to be used for the return operation. Also naughty,
	but keeps the typecast function interface to a minimum.
- Provide Set/Get functions but typecast to some uniform shape so that we 
	can put them in the main Finfo class without juggling through a 
	valuefinfo class. Do type protection via the finfo's ftype... can we?
	Yes, the set< T >  function can build a temporary ftype for the
	comparison.

=============================================================================
5 Jan 2007

After messing around a fair bit with finfos, I think the best bet is to go
ahead and reimplement essentially the same functional set as before, but with
an eye to cleanness and moving all type-specificity to Ftype. Later we can
look at further merging of concepts.

Implemented the basic message passing SrcFinfo and DestFinfo, compiled.
Time to check it in. Revision 57

Did a preliminary unit test to show that the Src and Dest Finfos can 
manage the setting up of messages.
Now to try sending information.

Did so, after lots of additional fixes. Revision 58.

Accessing finfos:
- Ptr to vector off Element*
	- Tricky to extend
- vector off Element* where first entry is always self, and points to cinfo,
	which points to array of finfos for default fields.
	- Each data Finfo points to a cinfo which gives a further set of
	finfos obtained by indirection. Their use is fine for get/set,
	but for real messages we need to copy the nested finfo, put it into
	a new finfo to live on the finfo vector. The new finfo will also
	handle indirection.

=============================================================================
6 Jan 2007

Looking at handling nested fields. OK as above up to the generation of a 
new finfo to deal with it, but not good for messaging. Functors are an obvious
way to pass in the extra indirection info, but this would add a minimum 2
indirections to every func call. We would need a wrapper functor with
a pointer to the polymorphic class that executes the func, because functors
are pass-by-value. Then the virtual func would cost at least another 
indirection. Original plan was to provide a wrapper Element* to do this.
It would do the lookup of the nested part of the data, and the assigning 
func only needs to know the final data type. Issue is how to manage this
wrapper Element. We would need to pass it back in the respondToAdd, and
the incipient Conn would need to know about it to replace the primary
Element.
Alternatively: Can we design a recvfunc that is precompiled but looks up
some extra info to find the other parts of it?
Two possibilities: 
- Template off about 3 recvfuncs with indices, and send out
whichever is needed. Rarely will we need more, complain if it happens. These
just look up the appropriate entry when needed. Messiness here with scaling
and with predefining a load of recvfuncs.
- Use the conn index to look for a matching entry. Slightly slow for looking
up, but saved because we will rarely have many. No issue with scaling.
I like this. The RecvFunc simply says, look for the entry in the extended
Finfo table which matches this, and do your operation with its help.

void extRecFunc( Conn& c, T v )
{
	ExtFinfo* f = findExtFinfo( c ); // Match it using the Conn index.
	assert( f != 0 );

// Here the lookup func is wrapped into the indirection element
	TempConn tc( c, f->data() ); // Here we set up an indirection Element
				// to replace the one from c. 
				// Or perhaps TempConn tc = c.tempConn( e, f->data() );

// Here the nested recv func is applied to the looked up data part as held in
// the indirection Element.
	reinterpret_cast< void ( *ofunc )( Conn&, T ) >( f->origFunc() ) ( tc, v );
}

Slow building up of many things here. Began with implementation of Cinfo.
Begun implementing ThisFinfo, which handles the object itself.

Checked it in as version 59.

Other pieces:
ValueFinfo: Need it to understand the API we will need for fields.
IndirectFinfo: Manage the above function and recvfuncs
ObjFinfo: A finfo that refers to a nested object.
IndirectElement: Manage lookup of data() internally.
DynamicFinfo: Finfo to be made on the fly for handling non-compiled operations.
	Looked up using the cinfo index.
=============================================================================
7 Jan 2007

Putting preliminary implementations together for various things, just to
clarify implementation possibilities. Lots of things coming together here,
and now I should steadily work through implementing each.
* Class definition through array of Finfos.
* Finfo lookup
+ Value fields
- Nested fields
- Array fields
- Shared messages
+ Dynamic messaging: To value fields
- Dynamic messaging: To nested fields

Getting close to sending messages using the class definition. Bug somewhere
in how the numbering of msgsrcs is done.
Also SimpleElement::add is not defined, but doesn't seem to bother it.
Possible issue is  SimpleElement::insertConnOnSrc

=============================================================================
8 Jan 2007

Finally got a simple network with messaging to work, various bugs ironed out.
Time to check it in. This is revision 60.

=============================================================================
9 Jan 2007.

Got first level of finfo lookup to work, no bells and whistles yet. Checked in.
This was revision 61.

=============================================================================
10 Jan 2007.
Beginning to set up ValueFinfo, which in large part also involves defining
DynamicFinfo.

Trying to compile.
=============================================================================
11 Jan 2007

Horrible mess compiling, obscure error messages about vtables that did not
identify the source of the problem. Turns out it helps to have an object
file rather than just inlines, because then the compiler deigns to explain
what the problem was. The problem was that in the base Element class I had
not put the =0; when defining a pure virtual.

Anyway, checked this whole mess in prior to doing the next stage of getting
data field assignment to work, and then the messaging to value fields.
This was version 62.

Now got simple set and get to work. This entailed development of the listFinfos
function that ramifies through many classes, just to test that the
finfo was a valid one. The function has other uses too, which is why I 
bothered. Checked in as version 63.

=============================================================================
12 Jan 2007
Now working on messages to and from Values.
Setting up a rather big seris of tests for this. First stage was just
doing the controls: ensuring that the regular messaging works. Works.

Got set message into a ValueFinfo to work. Checked in as version 64.

Currently a little stuck on line 983 in the unit tests. dval of e0 has
changed, and I don't know why.
=============================================================================
13 Jan 2007
Need to use the MsgDest ranging to monitor if a DynamicFinfo is invoked by an
incoming message. Actually reduces work when we are changing conns.

Architecture issues pending:
- Parallel messages
- SWIG
- Class init and MPP
- Solver messaging
- Scheduling and clock juggling
- Field objects
- Object/field ids across nodes
- Serialization and persistence: data
- Serialization and persistence: messages
- Multithreading options.


=============================================================================
14 Jan 2007

After much messing around, figured out why there was a problem in unit
tests when I tried --proc--> e1/procout --> e0/dval --> e4/dsum
Turned out not to be an issue with the messaging, which worked, but with
the field gets, which failed when confronted with a DynamicFinfo. This led
me to do some general reorganization of the set/get functions so that they
are now part of the main Finfo base class with delayed typing.
So we now have messages going into and out of fields. Still more variants
to test, but first to check it all in. This was revision 65.

Now testing  --proc--> e1/procout --> e5/dval --> e6/dsum";
where we first add the message from d5 to e6, then the trigger. Currently
it fails.

Yet more fixes to how the DynamicFinfo handles messaging, and how it is
set up by the ValueFinfo. Now it works.

Then I went through adding further tests:
trig then dval: --proc--> e1/procout --> e7/dval --> e8/dval";
dval then trig: --proc--> e1/procout --> e9/dval --> e10/dval";

All OK. Still remain to handle shared messages, but otherwise things look
pretty good here, and a very general solution so far. Time to check it in.
This was revision 66.

Running into problems with the PtrFinfo. The issue is the usual one of 
providing a static function for set/get, while having the available func
as a different function ptr. functors would be easy, but I don't think
the code will allow it.

=============================================================================
15 Jan 2007
For now, defer the problem of ptr use for set/get. Require that if one
wants to access the entire data field, one should define it also as a
ValueFinfo for itself.
Back to the PtrFinfo. I'm able to generate a nested set of DynamicFinfos
using the recursive match operation. But where and when does the returned
Finfo get used? If used for set/get, then it is used once and should then
be deleted. if used for messaging, we need to anchor the DynamicFinfo on
the elm. Perhaps the add operation can trigger a call within the
DynamicFinfo to check if it has been moored onto the elm.

=============================================================================
17 Jan 2007
Let's start by splitting up the problem.
- Separate DynamicFinfos for each class. Later merge if good.
- ArrayFinfo, DynArrayFinfo: ValueFinfo for arrays.
- NestFinfo (to replace PtrFinfo): ONLY for nesting, refers to a known Cinfo.
	NOT for assigning values, at least not at first.
- Figure out if DynamicFinfo handles Dest->other and other->Src cases.

ArrayFinfo: A variant on ValueFinfo and deals with specific, known classes. 
- No further nesting. 
- User provides 
	void set( const Conn&, T, unsigned int index )
	T get ( const void*, index )


NestFinfo( const string& name, const Cinfo*, void* (*)( void*, unsigned int index ) )
- Matching: identifies traversal, index and nested field. Looks up
	Finfo for nested field. Generates a DyNestFinfo.
- Only does nesting, no sets or gets at this point for field as a whole.
- set, RecvFunc: Nested Finfo->ftype()->nestFunc()
	which uses DyNestFinfo.
- get: NestedFinfo->Ftype()->getFunc but needs to be invoked from DyNestFinfo.
- add: Wrapper function to look up actual target, fake the conn?
- respondToAdd: ?
- DestFinfo: Same as Set
- SrcFinfo: DyNest provides dummy Element to fudge MsgSrc indices
- ArrayFinfo: 
- NestFinfo:
All in all, the NestFinfo has a pretty formidable set of things to do.

Another approach:
- Use DynamicFinfo for all funny messages, but look up supplementary info
efficiently in the same way that Synapse info is looked up.
- Use different kinds of DynamicFinfos, but look them up using efficient
indexing a la synapses.


OK, current approach:
- We'll work out how to index the DynamicFinfo as needed.
- We'll create a new DynamicFinfo as soon as the 'match' function is called.
	We immediately place it on the finfo_ vector.
	By definition, future calls would hit the DynamicFinfo first,
	so match should only be called once on any object.
	(May need to refer between DynamicFinfo and original Finfo in case
	we have more messiness here.)
- If the subsequent function is set or get, it checks if the DynamicFinfo
	is unmessages. If so, delete it as soon as op is done.
- If the subsequent function is messaging, add/drop messaging and delete
	DynamicFinfo if now empty.
- Add, respondToAdd, and drop now operate on the new dynamic finfo, NOT on the 
	original finfo. So these operations need to be handled only by
	the DynamicFinfo.
- Whatever recvFunc or other op is needed, is handled by the original
	Finfo, which typically refers these to the Ftype. In all cases
	the DynamicFinfo, or a subclass, provides additional data.
- set/get remain a problem. They really need to refer somehow to the
	parent Finfo. I suppose that only Value and DynamicFinfos should
	support set/get, in which case we could organize it. Even better,
	we never actually expose anything except the DynamicFinfo...
	oops, we wanted also to do DestFinfos.

=============================================================================
18 Jan
Running into all sorts of problems with set/get for funny finfos.
Perhaps I should stick to implementing messaging operations alone, and
do set/get through messages. Question is whether overhead will be too much.

Try:
- DynamicFinfo that can handle indirection to forward operations for
	doing add or respondToAdd.
	- Need common mechanism for doing this forwarding.
- Value, Src and Dest Finfos that provide add and respond.
- Array and Nesting Finfos to provide info for DynamicFinfo to do indirection.
- Ftype to deal with all function typing. Clean up ValueFinfo so it doesn't

- ValueFinfo with setFunc and either a getFunc or a trigFunc given by the user.
- ArrayFinfo with setFunc and either getFunc or trigFunc, indexed by Dynamic.
- 

=============================================================================
19 Jan 2007
Should I modify the Send so that there is a sendWithIndex that passes
an extra arg, of the conn index, to each target. Used for synapses etc.
This would have the implication that the RecvFunc need not know anything
at all about the Element. It would be an entirely local operation.
No, won't work. The outgoing Send commands in a recvFunc will need the
Element info.

Now into concrete compilation. 
- Compile and test. Currently stuck with the usual template header
	dependency headaches.
	Now compiled, but get immediate segve
- Eliminate ValueFinfo<T> and just have the generic operations, rest by 
	Ftype. Compile and test.
- Make an ArrayFinfo
- Make a NestFinfo
=============================================================================
20 Jan 2007
Conversion under way. Somewhat to my surprise I have a working 
(clears all unit tests) intermediate version where DynamicFinfo
is handling all the adds and respondToAdds, and various mutations
have happened to Ftype1.

Checked it in. It is version 67.

Now lots of changes going on to get the ValueFinfo to become non-templated
and shift stuff over to Ftype. Ftype1 has been subclassed into variants
for handling Value, Array and Nest.

Again, surprisingly, it worked and cleared unit tests with relatively little
effort after many rather deep changes. Checked in as version 68.

Now let's set up the ArrayFinfos.

Point here: The DynamicFinfo needs two sets of setFuncs and getFuncs.
The inner set is the set that the original object passes it. These are
used by the Ftype to generate the static setFunc and trigFuncs that
are seen by the outside world, such as messages.
Point is that the DynamicFinfo needs to have the whole lot accessible to it.
But possibly we could have the Ftypes accessing the funcs in a
setFunc( Finfo ) type operation, which either passes back the statically
defined Ftype variant of the function, or the variant that the parent Finfo
generated. A bit too convoluted. Let's just have the Finfo pass the 
correct functions in to the DynamicFinfo, which now has rather a lot
of args.

Cleaned up use of set/get funcs in Finfo. Separated the role of different
types of Ftype. Redid the set<T> and get<T> operations, they are more
general now and should work with arrays and nested fields in due course.
Yet again surprised at the whole thing clearing the unit tests.
Checked in as version 69.

Next to set up unit tests for Arrays, then for nested objects. Begun.
Barfs.

=============================================================================
21 Jan 2007

Fixed up minor bugs, fixed issue with naming in the DynamicFinfo. We really 
need to have the fully specified name given to the DynamicFinfo so that
a regular name match is sufficient to identify it. Updated the UnitTests
so that they test Set and Get on the Array.

Some issues with looking it up because conn index is zero but so is conn size
on the dummy element.
This is a more fundamental problem. It happens because we assume each
DynamicFinfo is associated with at least one incoming Conn. But if we
are doing a set/get, we have unassociated DynamicFinfos sitting around.
Worse, we could have multiple of them unless we can guarantee that the others
will be deleted at once. Multithreading of shell is an issue here.

OK, one issue dealt with. For set and get we do not rely on the lookup of
DynamicFinfos, we use the one provided. However, we still have 'droppings'
of old DynamicFinfos left sitting on the SimpleElement finfo_ list. These
can be identified by having no incoming Conns, and can be deleted at
some garbage collection stage. Perhaps addFinfo would be a good stage for
this.

Implemented the fix, ran a few unit tests, looks like ArrayFinfo set and
get now works. Hooray. Checked it in as version 70.

Now to check messaging to and from array entries.
Great. This worked right off. I have done most of the variants on
message to and from regular, Value and Array Finfos. 
Checked it in as version 71.

Looking at NestFinfo. This will need a functioning cinfo infrastructure.
It has a problem because Finfos are const. So we really want the nested
class to be passed in as a cinfo, which constrains us to having the class
already defined. This rules out an initialization step. Given the
usual static initialization approach, we need something clever to ensure
that the nested class is defined first so its cinfo can be looked up.

Anyway, started implementing NestFinfo.h using this idea. Should march
on through. Need also to back up all this work.

=============================================================================
22 Jan 2006
Did complete disk backup.
Muddling along with Nest implementation.
=============================================================================
23 Jan 2006
Heard from Dave Beeman that Jim has decided to cut MOOSE out of the loop with
his incarnation of GENESIS, and to go with Hugo's Neurospaces instead.
Various decisions follow.
- Takeover and Makeover of the MOOSE site. 
- Whether to do our own graphics. If so, how.
- Tie ups. Erik, Sharon and Padriag, Sys Bio people.
- Renaming and release plans
- Announcements and writing
- Prioritization

Anyway, for now let's get the Nest implementation to work. Main obstacle now
is defining its scope.
- Consider a channel. It has nested in it several interpols.
Actually we would normally do this using messages, so that the interpols
could be shared.
- Consider an nreac. It has nested in it an array of reactions and molecules,
all computed efficiently in one step. Same rate for the lot, but an array
of state variables. But this could be set up using the regular array. Do I
really want it to look like many steps inside?
- Consider diffusion. Idea is to have a single Element managing an array of
identical molecules, and superimpose a diffusive calculator on it.
But I would like to refer to each molecule as if it were the real thing.
- Consider an array of 1e6 neurons. They all share the same heirarchy. We
build one neuron, and then say that each compartment actually represents
the 1e6 corresponding ones.

Two key points:
1. Often we want to have generic access plus a black-box solver on top.
2. Other times we want to have generic access but preserve a certain messaging
	structure for all the pieces. Often this would be taken over by
	a solver.

Both these cases seem to require an ArrayElement rather than a SimpleElement.
Here we can acheive the message replication effect by having a local variable
in the ArrayElement to indicate which index we are on. All the old messaging
Just Works using the Element::data() function. Only issue is how to get the
whole lot of elements to coordinate this indexing. Perhaps a special message
to the whole lot of them? 
createmap /neuron /map 100 100
le /map
	neuron[0..9999]
showfield /map/neuron[2703]/compt/Vm

So here the index on the neuron[2703] would tell neuron/compt which index
to use.

Any attempts to modify message structure on an individual basis would be messy.
But necessary, for example, for synaptic connectivity. The ArrayElement would
need an extra internal table to direct the conn_ entries correctly.

Would like to have vector messaging here.
Would like to have vector Process operations, provided the thing isn't
solved. Or even if it is.
Would like to have solver messaging set up in a similar invisible way for
zillions of children.

For now: Move on. Let's get something that works and that we can use
for computing. Here is a list of things to work on with current priority set.

- SWIG
- GENESIS parser
- Windows compilation				Assign Niraj
- MOOSE web site.				Assign Harsha to look at it.
- Scheduling and clock juggling			Me, also get an idea of obj
- Implementation of some basic classes		Me, also test somethings
- Class init and MPP
- Parallel messages
- Solver messaging
- Field objects
- Object/field ids across nodes
- Serialization and persistence: data
- Serialization and persistence: messages
- Multithreading options.
- Array Elements.

...........................................................................

Working on SWIG.
- varargs in commands: Avoid them. Let the Genesis parser wrapper
	code deploy the correct one.
- Commands: Many of them use the shell object as a global. But
	there is a strong assumption of string based object identification.
	That is why . and .. make sense. 
- Should we deal with Field objects rather than strings? it would be nice
	to be able to use the scripting languages to do assignments
	etc on these rather than just replicate the GENESIS setfield/getfield
	commands. In other words, we should be able to do
	/foo/bar = /zod/caprice.
For now:
- Use shell commands with string args
	(exception is setfield and getfield, which have typedefed args.)
- Do not use varargs.
- Do using namespace shell::, but from the viewpoint of a single instance of it
	as if it were a global. Looks like I need to provide a lot
	of little wrapper functions. Alternative is to make them static
	functions of the shell class.

Begun on a test program

=============================================================================

24 Jan 2007
Got the little test program to work with SWIG and python, after much
muddling around. Now to use it to set up a useful system.

I'm sure if I knew more SWIG I could figure out how to represent objects
from MOOSE within Python directly and access fields as though they were
local entities. That can wait, but the only issue is if I get started
with the current approach, will it need to be rolled back? If so, will
it be hard to? I think it should be fine either way. Let's do it.

OK, got the whole of MOOSE to compile with Swig.  Easy after the earlier
prototyping. Currently I have named it 'shell', obviously should be
pymoose or some similar name. Also the funcs in it are still dummy ones.
There are still issues with having the .py files in the right place. This
is a bit odd, as it means we have to have multiple files available to
run python. I guess there is some standard way around this.

Anyway, this is a good time to check it in.

=============================================================================
25 Jan 2007
Now to implement the basic parser commands. Will fill out as I go along.
The other bit is to tie it into the GENESIS parser too, in parallel.
Part of the latter process will also help with internode commands, since
I need to serialize shell function calls using a single function that 
speaks argc, argv.

I've asked Eric Mueller who I think was the PyNest person, about how it is done.
Also wrote to our buddy Joe Svitak.

Now some nomenclature. We need specifically to decide how to name fields.
The confusion arises because Finfo names for MsgSrc, MsgDest, and SharedMsg
may look similar. Let's do this:

- All MsgDests are just given a regular lower case name, such as 'child'
- All SharedMsgs likewise.
- All MsgSrcs names should be suffixed with a Src: 'childSrc'

The reasoning is that MsgDests are often treated like functions, so we
don't want confusing names. SharedMessages are always composites, so
src and dest do not make sense and the same name is useful for either end.

Implemented Neutral. Python sees it and can create and delete it.
Checked in. This should be version 73.

Started on Neutral unit tests. Segv.

Progress on the cleaning up of messages upon deletion.
Struck by an issue with conn indexing in SimpleElement. Cleaner approach is
to provide connBegin( unsigned int src ), connEnd( unsigned int src )
as iterator ranges.
But first lets fix the current problem and check it in before
redoing the interface.

Now working on doig the interface. There is a small expansion in number of
functions but it does keep MsgSrc out of the public interface for 
SimpleElement. Still pegging away at it.

=============================================================================
26 Jan 2007

Did makeover of eliminating MsgSrc and MsgDest return functions from
SimpleElement. Also other cleanups.

A bit stuck on the Neutral test, but I suspect that what is happening is that
I am cleaning up the children which alters the conn_ vector even while I
use an iterator for it.

Perhaps need to do Delete in 3 stages:
1. Mark elements for deletion.
2. Clean out messages to non-marked elements
3. Delete.

We can't merge 1 and 2 because inter-object messaging may not occur in
the same sequence as marking. 
We can't merge 2 and 3, because then there would be already deleted child
elements being queried about whether they were marked.

This would also remove the responsibility of cleanup from ~SimpleElement,
which is not up to the job.

Much messing around later, we have something that works.  Deleting turns
out to be surprisingly complicated. There are also other pending things to 
delete on the SimpleElement, later. For now check in. 
This was version 75.

Implemented Finfo::isTransient as a test when deleting SimpleElements,
need to work out unit tests. Perhaps create a dummy Finfo or so and
have it do assertions when it is deleted. OK, done, works.
Checked in as version 76.

Some interesting ideas from implementing Neutral:
- Fields for parent, child (array type)
- Don't want Element::delete to be a message called from parent. Actually
	it should be called from self. And at this point the child operations
	involve 3 calls. Delete should be a single call.
- Messages visible as Element/Field combos, using node-independent
	representations of each.
- Global Element identifier? This comes up in context of parent/child fields
	Also makes sense for Python linkage
	Also makes sense for parallel implementation.
	Two possibilities:
		- Each node has vector indexed by id, for all Elements.
			Off-node Elements point to appropriate postmaster
			for resolution.
			- Fast to access # to Element
			- Need help to go the other way, or each Element stores
				its own index.
			- One ptr per Element. If we use lots of arrays,
				this isn't too bad. Otherwise, we may
				end up handling 1e9 Elements.
			- Not clear how to deal with distributed arrays.
				Possibly local ArrayElement would have to
				keep track of node partitioning.
		- Each node has one vector indicating message ranges and
			their node ids. Other vector handles local Elements.
			- Terribly slow to access, possibly need map for first.
			- Gets worse with greater node decomposition.
- Global Finfo identifier.
	Easy to implement for fixed Finfos. 
		Relative: Each class has its own, starting from 0.
			Needs first to look up object, then Finfo.
		Absolute: All defined fixed Finfos get their own id.
	Hard to do for transient Finfos.
		Has to be some form of relative indexing for each Element.


Immediate stuff:
- SWIG and parser working
	- Need Element heirarchy
		+ Need Create operation. Let's put it on Neutral
		+ Need Delete operation, discussed above. On Neutral
		+ Need getfield for parent, also discussed above.
			- This led to discussion of what is returned.
		- Need getfield for named child in order to get paths.
			- Assoc mem array Finfo?
			- Block messaging to and from it so no dynamic form?


Implemented several of the ops in Neutral. Created an Element::id().
Compiled. Yet to use and do unit tests.
Checked in as version 77.

=============================================================================
27 Jan 2007
The Neutral::create operation turns out to be pretty useless for in-code
use. As it is a RecvFunc call, it does not provide a way to return the new
Element. This may be OK if we have the 'el ^' equivalent command from
the script, but for in-code purposes it is a pain.

Need to work through use patterns for an Element id integer.

=============================================================================
28 Jan 2007

Analyzed the use patterns for eids. The bottom line is that they add little
to the internal computation of MOOSE, but they would be a useful
interface and scripting construct, especially as we go parallel. Here is the
analysis.

Uses: 	1. Unique parallel element id
	2. Persistence and changing data holders
	3. Interface: RecvFuncs and Elists

Alternatives:
	U1:	String path: Lengthy. Needs traversal.
		Elm ptr + node#: Ptrs are a bad thing to refer to across nodes.
		Not constant when object is moved between nodes.
	U2:	Fine for string path.
		Elm ptr approach would involve changing all references. Ugh.
	U3:	String path is fine.
		Elm ptr is ugly.

Use cases:
	1. Elists across nodes:
			- Value assignment
			- Message setup
			- Loops
		This is an issue somewhere between scripting and the shell.
		The shell would benefit from compact elists across nodes,
		if it could parse the job out between nodes.
		Arguably, the original wildcard is still more compact and
		can also be parsed between nodes.
	2. Handle for script languages
		Still need to get a feel for how SWIG would use it. Want to
		have elements appear with all their fields when referred to.
	3. Array elements: Do we have a unique id for each or treat them
		as a single one?
		This is an interface as well as costs issue.
	4. Messages sending element ids around
		No experience with this, but conceivably higher-order and
		algorithm objects might like this. Certainly cleaner than
		passing element pointers around.
		For example, the shell object might want to use eids instead
		of name strings a lot of the time. Of course, this complicates
		the internode shell commands which were hitherto using strings.

Level of exposure/API:
	- Don't bother for anything at the data flow level.
	- Use partially at shell level
	- Use extensively at script level, but no use for old GENESIS parser.

Problems and solutions.
	- Cost.
		Array form:
			1 big vector of element ptrs, indexed by eid. Off-node
			elements refer to other postmasters.
			Each element has its own eid.
			- Exorbitant memory use 
			- Especially bad if we have unique indexing for arrays.
			- Access is very fast.
			- Very simple.
		Range-bound tree:
			Each tree leaf has low and upper bound, and location
			for start, which could be an array index or node #.
			SimpleElements on a big vector, can use leaf
			info to compute their eids.
			- Very low memory use until objects start to get
			seriously shuffled between nodes. Unlikely to happen.
			- Would handle unique indexing of arrays very nicely.
			- Access log N, but tolerable if mostly contiguous.
			- Complex.

...........................................................................

With this in hand, move on to define the Shell object that the parsers
have to talk to.

One constraining requirement: Shells on different nodes must talk to each
other. Earlier we just passed strings so a single RecvFunc could handle all.
This is a bad idea because it puts a lot of parsing back onto the Shell.
Options:
	Massively shared message.
	Block form of regular message with distinct segments for data.

I think the massively shared message will work. Let the postmaster figure
it out.

...........................................................................
Another frequent issue: Finfos. 
- Could be global. Element independent fids. This would fail for
	local finfos such as dynamic ones or extended fields. Also,
	how would you deal with array finfo indices?
	- Dynamic finfos with same name could be picked up using 
	global fids.
	- Array finfo indices could be an optional arg.
	- In any case the script has to refer to the element at some point
	to get back the ids. But perhaps if it reuses them... Or does
	it use them at all times?
- Relative finfos. This means that all finfos with the same name have the
	same number (fid).
	
	Or I could stick with strings for finfos. They are short too.

For now stick with strings.
...........................................................................

Finally begun a bit of coding with Shell.cpp, to start to implement some
of these. The first step is path2eid and eid2path. Partly done.

=============================================================================
Jan 29 2007

Now need a function to return a vector of uints for message dest elements.
Will later need one to additionally return info about the finfos that
they target.
Since I'm doing all this in the Neutral, I want a systematic way to
pass in an argument (say a finfo name) and get back information. Something
like a value, but a looked up value. Or think of it as a get with additional
argument(s) to specify what to get. This is easy to composite as two
messages, one with the arguments and one with the return value. In other
words, a shared message.

How to implement. Shared Finfo needs a list of ftypes and where it is a dest,
of RecvFuncs. Perhaps use pairs, and src funcs could be dummys.
Need a composite Ftype for typing comparisons.

=============================================================================
Jan 30 2007

Many intermediate steps on the way to getting a functioning shell.

- Implemented SharedFinfo and SharedFtype
- Implemented Neutral::lookupChild
- Implemented set( Element* e, const string& finfoName, T val )
- Implemented set for zero-arg finfos.

Now it compiles and passes unit tests, but I haven't begun the many tests
that will be needed for checking all the above. Anyway, time to check it in.

That was revision 78. 
On other fronts: Niraj has successfully compiled and tested a somewhat earlier
revision on Windows. The main issue was that the RecvFuncs being passed in
were referenced directly, rather than using &funcname. A few other minor
fixes also done. Unit tests still work. Checked in.
This should be revision 79.
=============================================================================
Jan 31

Added in revision 80 with a little documentation.

Worked on unit tests for SharedFtype. Passed painlessly. Checked in as
revision 81.

Worked on unit tests for SharedFinfo. Very painful. Compiled, does not pass.
Lots of work to be done here. Checked in as 
revision 82.

=============================================================================
Feb 01 2007.

Begun unit tests. Initial error turned out to be in SharedFtypes. Fixed. Now
messages are formed correctly. Later error turned out to be bug in 
DynamicFinfo::match(connIndex). Fixed, clears unit tests. This means
that shared finfos seem to work. Checked in as
revision 83.

Two separate issues with handling all heirarchy and shell ops through
RecvFuncs:
- Looking at the Neutral, it seems like we need a way to move many of the
DestFinfos and even SrcFinfos off the default list, and only make them when
they are needed. Save us a lot of space.
- Many of these calls are multi-arg and require a return value. So
some kind of message is needed, the set/get commands don't work. So lots
of quick message creates and deletes.

=============================================================================
Feb 02 2007
One possibility is to use something like the get() function but with 
extra args. We will also have to ensure that the operations get passed to
the required node by shell-to-shell communication so that the get() is a
local function.

This enhanced get() would also help for array finfos. How would we 
set it up? Using 
bool getByLookup( const Element* e, const Finfo* f, T1& v, const T2& lookup )

OK, now how would we use it? 
- Could automatically set up as a SharedFinfo, much like triggers and 
data parts were in ValueFinfos.
- Avoid using DynamicFinfos for arrays. Actually arrays would be a good
test case.

=============================================================================
Feb 03 2007

Working on a LookupFinfo, done a version for LookupFtype.
Problem in the match() function. All is similar to the ArrayFtype but how
do we deal with the index in the match operation? We may have to refer it to
the Ftype to convert. 
- Or, we could permit exactly two types for lookup:
int and string. But we may want a continuous lookup: eg., lookup table.
- Or, just block the indexed match operation. This would eliminate all direct
accesses to fields, and insist that we access by lookupGet/Set or by
messages with an extra arg.
- Or limit it to types where conversions to and from strings have been defined.

=============================================================================
Feb 04 2007
Slowly working in the LookupFinfo and associated classes. Initial compile
worked and didn't foul up any existing unit tests. Now added LookupFinfo
unit tests and there are plenty of compile errors.

=============================================================================
Feb 05 2007
Marched through huge set of compile errors arising out of definitions of
LookupFinfo and LookupFtype and setgetLookup. Compiled. Cleaned up unit tests.
Works both for assignment and for ArrayFinfo style messaging to specific
index entry. But haven't tested yet for shared messages. Anyway, time now
for checking lots of stuff in.
This was version 84.

Now to go on to the shell and SWIG stuff, which is what set all this off.

Begin on unit tests for the shell. Usual croaks.
=============================================================================
Feb 06 2007
Really baffling bug in Shell.cpp::eid2path. Name being build up for path
is not getting set properly.
Turned out to be most likely due to some strange properties of the 
ASSERT macro set up using #define. Possibly the function was being called
multiple times in the macro without my realizing it.

Various other headaches, most fairly ugly. Anyway, now completed this small
set of Shell unit tests for create, eid2path and path2eid. Time to check
it in.
This was version 85.

=============================================================================
Feb 07 2007
Added le command to shell. This necessitated making a suitable function in 
Neutral to give an elist of children. Still not sure how best to tie this
into the parser. Anyway, checked it in.
This was version 86.

Now to tie in the two main parsers, SLI and Python.

Initial part of tying in Python went fine. But when I try to run it there are
issues with initialization of the root element. Trying to do it through
sttic initialization, but the ordering is not good.

Sorted out some aspects of initialization, and did Python test too. After
various fixes, seems to handle create and le within Python. Checked it in.
This was version 87


Now shifting over to SourceForge based subversion so that development
can be spread out more. The revision number there was version 27.
Checked in the past week of work, future updates should be smaller and
more frequent.
This was version 28.
Error in the Makefile for the genesis-parser subdirectory, didn't update
it with the rest in version 28. Checked in new version.
This was version 29.
Niraj tells me there were a few bad files sitting around in the DOCS
directory. I've cleaned them out. Checked in.

Now to tackle integrating the old genesis parser. The interface code for
the old MOOSE is in GenesisParserWrapper.cpp.
Key question: How should the shell communicate with 
	- other shells, e.g, on other nodes.
		Make regular messages, assemble in a big shared message.
		This will entail replacing the current functions in Shell.h
		with field-compatible functions. They will be used both
		in direct set()/get calls, and also in a big shared message.
	- Swig
		Currently we use a set of interface functions that
		accept string arguments. Could readily convert to integer
		arguments too. But it would be best to get inside the
		wrappers so that MOOSE objects look like regular objects.
		It would also be nice to have a SwigWrapper object that
		could talk politely to the shell via messages, the same
		ones that go between shells.
		Should be possible. See this page:
		http://www.swig.org/Doc1.1/HTML/Python.html#n6
	- GenesisParser
		This needs func( argc, argv ) format for all funcs. 
		But it often does ugly optargv stuff, so we will really
		want to have a separate set of functions here to call the
		reference ones for the Shell.
		We have an existing GenesisParserWrapper object from the old
		MOOSE. This could readily be adapted to be an object in 
		MOOSE07, and communicate cleanly with the shell using messages.

A related point: Should data output be handled by the shell directly
(to cout) or should it just be returned to the calling function? If so, how?

Discussed with Subhasis. It seems that the Shell should never handle output
itself, instead pass the data to the calling parser.

Also, many of the object hierarchy functions belong not in Shell, but in
Neutral. Shifting them there.

=============================================================================
Feb 10 2007
Interesting problem with static initilizers as I try to make the Shell into
a proper MOOSE object: The Neutral Cinfo is needed to make Element::root.
It is failing because it hasn't been initialized.

=============================================================================
Feb 11 2007
Nasty recursion issues with the static initializers. After much messing around
I have a system where each Cinfo is initialized using a static initializer
function, which is called both by the MOOSE object for that Cinfo,
and also by the static initializers for any derived classes.

There are a fair number of development lines now pending for the scripting:
- Getting integration with the GENESIS SLI.
- Getting shells to talk to each other
- Filling in more shell functions
- Implementing the id wrapper class for SWIG
	- Implementing Finfo parsing to generate SWIG/python class wrappers.


Working on GENESIS SLI. First issue:
Most of the funcs that get added to the parser vocabulary need to talk to
MOOSE objects. In the old code I had the parser include a field for the 
Shell and GenesisParserWrapper. Here I want to do it all using messages
from the GenesisParserWrapper. I have a bunch of void( * )(argc, argv, Shell* )
functions that get into the vocabulary. Can I eliminate the Shell*? Should I?
Each of the funcs needs ultimately to send messages and call setfuncs.
Note that for Python I just use the eids.
=============================================================================
Feb 13 2007.

Building the GenesisParserWrapper around the idea that it will be connected
to its shell by messages, and that the GenesisParser object knows the id
of the Element it is on. It needs this to pass to the various functions that
have to send messages around, especially to the Shell.

Now major cleanup to do on the GenesisParserWrapper to use the id and
messaging rather than the Shell pointer it had previously.

=============================================================================
Feb 14 2007.
About halfway through a very messy recompile of GenesisParserWrapper.

Getting close
Need a systematic way of finding the appropriate src/dest index, or even
better, for having them enumed by the name of the field.

=============================================================================
Feb 15 2007.

Managed to get compilation to work, still to test. Old unit tests are fine.
Will need a lot of cleaning up of src/dest indices.

Implemented biophysics/Compartment. This is really for Subhasis to go ahead
with an example class for the Python implementation. Should be functional,
except that it needs proper scheduling to work. Compiles, old unit tests
work, new ones still to implement.
Checked in to the SourceForge site. Now at revision 34.

=============================================================================
Feb 27 2007

Put in code to inherit finfos. Things fall apart here in several ways.
- The indexing of local fields is shifted. This messes up UnitTests.cpp:458
	and onward. Trivial.
- The numbering of messages just got even worse. I need to initialize
	some static fields with the message names so that I can send things
	easily. Either that or define wrapper funcs.
- There will be a proliferation of message slot requests. Most of these
	will sit unused but occupy space. Various measures:
	- Allocate slots only as needed. Always parent, not always child.
		Expand slot vector as message creation requests occur.
		- Ordering of slot vector needs to be so that common ones
		are sooner.
	- Many finfos, even src and dest ones, need not have default slots
		given. The finfos are used rarely so we can put in a finfo
		reference in the finfo array if needed. This is like messages
		to fields.

I have addressed the first two problems above. Unit tests were far from
trivial because indexing issues were everywhere. At the end of this we have
implemented two things:
- class inheritance and managing message slot access issues that result
- Generating a slot index from the finfo name so that the send() command
does not need to use hard-coded indices.


=============================================================================
Mar 01 2007

Resuming work on the genesis parser interface. Plan:
- Set up a shared message on Shell and on the GenesisParserWrapper.
	All the little funcs go back and forth through this
- Start with ce, pwe, le, create, delete.

Done first pass of implementation on the Shell. All these still remain to be
done on the GenesisParserWrapper.

=============================================================================
Mar 02 2007

Got Shell stuff to compile. Reveals an issue with the getSlotIndex: the
shared messages don't record names of individual parts of the finfo. Should do.
Checked current version in before going on to deal with the 
GenesisParserWrapper sending input to the Shell.
Checked in as revision 36.

Now dealing with GenesisParserWrappr.

Implemented GenesisParserWrapper side of parser message.
Compiled, unit tests OK, but not tested for specifics.

=============================================================================
Mar 04 2007
Working on getting SLI to be created, to talk to shell, and to run.

Did all of the above. Compiles and SLI is invoked. Currently the only thing
it does properly is to quit. le causes a core dump. Anyway, good time to
check it all in. Possibly some issues will crop up with the python interface.

Moving on to getting the functions to work, starting with le.
Ran into a morass of problems when trying to use sendTo. The issue seems to
be with the conn indexing. Introduced a whole bunch of unit tests for
the Conn::sourceElement and Conn::sourceIndex() functions.

Tracked down the problem: I was including both the Source and Dest vectors
in the counting for indexing of msgSlots in the shared message. Should have
used Source separately.
Many things now work: pwe, le, ce.
create sometimes works but:
- doesn't do Neutral (but does neutral!)
- doesn't do create neutral foo (but does create neutral /foo)
	- when we create foo, it puts a blank-name object in, it seems.
- doesn't create any object on anything but /
Most of these are now fixed.

Time to check in. 
This will be version 39

=============================================================================
Mar 06 2007
Delete works.
le looks at root element list if the specified path is not found
More generally, I need to implement unit testing for these functions.

Fixed le.
Implemented unit tests for GenesisParser. Set up tests for le, pwe, ce, create,
delete. This would be a good time to check it in, but I don't have net access.
For now, just copying the whole source tree into a temporary subdir:
mg3_rev40 because this would have been rev 40.

Continuing with the main branch.
Immediate goal is to get system to point where we can run the rallpacks,
preferaby a bit further so we can also run the Purkinje demo sans graphics.
This will also fit in with the solver code from Niraj.

Sub-goals:
- Parser upgrades: *echo, *showfield, *getfield, *setfield, *addmsg, *alias,
	reset, step
- New objects : channels, ca_concens
- Scheduling.

Working on getfield. This involves the implementation of string conversions.
strget is now working, but getfield is not.

=============================================================================
Mar 07 2007
getfield now works. Time to do another pseudo-checkin, which would be rev41.

On now to strset and setfield.

These now work and have been put into unit tests. Another psuedo-checkin, rev42.

Tried to echo the fieldList. Barfs. Fixed. It was a little problem with the
recursion in getting fields.

Also fixed problem of what to return when fields don't exist. Now it barfs
the same way GENESIS does.

Got showfield to work. Set up unit tests too. Time for another pseudo checkin:
rev43

=============================================================================
Mar 08 2007
Got the addmsg to work, but it does not go through the Shell. May need to
revisit later.

Got the alias to work. This is just an internal parser command.
Got listcommands to work too. This is also an internal parser command, easy.

Pseudo-checkin rev44. Now to put these incrementally onto the SourceForge
server. Incremental is best both for the historical sequence and to figure out
what happened if things break.

=============================================================================

Mar 10 2007
Begun work on HHChannel. So far only set up the .h and the Cinfo initializaton
stuff for the HHChannel. Some changes to the old mus variant of the HHChannel.
In the current version the channel has to handle its own process, rather than
be driven by the compartment. Compartment can jolly well wait for a new clock
tick to see what the channel had to say.

=============================================================================
Mar 11 2007.

First pass on implementing HHChannel. Compiled, all funcs in, but the unit
tests aren't done yet and nor is the HHGate, needed for HHChannel function.
Anyway, it goes through the regular unit tests and time to check it in.

=============================================================================
Mar 12 2007.

Working on HHGate. Two issues:
- Need to manage a couple of encapsulated Interpol classes. Would like to
use the automated inheritance of assignment operations, but the basecode
features for this do not yet exist.
- Need to work out how to manage initialization of the HHGate.
	- Have another bunch of messages from each Channel. This gets expensive.
	- Every time Channel fields are set, a new HHGate is created.
		- The HHGate is reused if the Channel is copied.
	- Do simple assignment on creation of HHGate. 

Dealt with idea for second issue. Now need to implement Interpol, test it,
and then come up with basecode features to let me put Interpols as nested
fields within the HHGate.

Implementation in progress...

=============================================================================
Mar 13 2007.
Implemented Interpol.
Done unit tests for Interpol. Somewhat painful, caught some unpleasant
and unexpected bugs. Time to check it in. Then we go on to incorporating
it as a component of HHGate.

Now working on NestFinfo, which was partially implemented a while back
and then dropped. We need it to implement the HHGate which contains 
two Interpols. Got the basics implemented, and it compiles. Set up unit
tests for NestFinfo, and those fail.

=============================================================================
Mar 15 2007
After much messing around with NestFinfo and related files, seems like the
best solution is to bypass the problem. Instead require that any nested field
look like a child element. The child element is almost the same as 
Neutral except that it may not be deleted directly, and it takes its
data value from the nested field.
Details:
- We create the HHGate. It has two Interpol objects nested in it.
- As soon as it is created, the postCreate function is called. For most objects
	this does nothing, but in this case it creates two child SimpleElements
	using the addresses of the Interpols as data.

We need now to have a callback when an object is created.

This is going OK, but it raises a problem in Cinfo::Cinfo because it requires
for the first time that we handle overriding parent fields with fields from
derived classes. Among other things, we need to match up slot numbers and this
turns out to be an absolute can of worms. Perhaps I should also guarantee that
overridden fields are type compatible.

Done this the hard way, added to all Finfos as a required function. For
several of them I need to shift to the .cpp.

Finally, all done, and we get the nested Interpols created with the HHGate.
Many changes done, time to check stuff in. That was revision 47. Now
we can actually go ahead with the channel stuff.

Starting on setting up the scheduling. On close examination, it seems 
like we don't really need the sched object. All operations should be doable
through calls to the jobs.
Slowly working out what happens with the ClockJob.
=============================================================================
Mar 16.
Very preliminary work on ClockJob. I am changing the ClockTickMsgSrc class
of previous versions into a much simpler TickSequencer class, which will
just send out appropriate messages to the child ClockTics rather than 
manage them directly. Lots of changes need to be set up together.

=============================================================================
Mar 17.
The earlier version used a separate class to juggle the sequence. I think
this can be done using regular messages and the clock ticks themselves.

Slow grind through implementation, long way yet to go. Should be able to do
a dummy compile soon enough.

=============================================================================
March 18, 2007
Implemented first pass at ClockJob and Tick objects. Compiles. They are each
about 80% complete. I have restructured the earlier rather complex and 
specialized scheduling code to use distinct objects and clean messaging.
It is still a bit commplex, but no more than the algorithm demands.
At this time I don't need the Sched object at all, a Neutral will do.
Next stages:
+ complete the sorting and message set up in the Clock Job
+ complete unit tests for the scheduler
+ Implement the SLI drivers for the scheduler: setclock, useclock and so on.
+ Unit test for biophysics objects.
- Connect scheduler up to biophysics objects, unit tests for action potl

=============================================================================
March 21, 2007

Next stage implementation of ClockJob. This time I put in the sorting of
ticks. This involves deletion of messages, which turned out not to have
been implemented yet for Finfos. So I went to all the Finfos and did
the implementation. This required that Elements handle the four Conn 
access functions: connSrcBegin/End and connDestBegin/End.
Compiled, no unit tests yet.
This was checked in as revision 49.

Put in a utility function Neutral::create for creating objects.
Fixed some bugs in the recent implementation of the dropAll in several
of the Finfo.cpps.
Further work on implementation of the scheduling.
Implemented and passed unit tests for scheduling.

Checked in as revision 50.

=============================================================================
March 23, 2007
Implementing the SLI drivers for scheduling. The useclock function requires
the use of Finfo::numIncoming and Finfo::numOutgoing. So another round
through all Finfos to implement these functions.
Then another pass through the GenesisParser and Shell to set up the 
function calls. Still a few loose ends, but the existing unit tests pass.

=============================================================================
March 24, 2007.
Checked in. This was version 51.

Need now to implement wildcarding so that the useClock function can be
implemented. Where does it go?
GenesisParserWrapper: 
	- Syntax is not really consistent for other parsers.
	- But it may be useful for other parsers, though syntax may change.
Shell:
	- Accessible to all parsers
Neutral:
	- Accessible to all developers as a generic function. Will we need it
	in other, non shell/parser code?

Put it for now with the Neutral.
Did cleaning up, remarkably little, of the old mus version of wildcard.cpp.
I am currently at the wildcardRelativeFind function which is just before the
unit tests.
=============================================================================
March 25, 2007.
Now on to unit tests for wildcards. A particularly ugly bug appeared,
manifesting not in wildcards but in the genesis parser. Used valgrind, that
showed up an unitialized value in the GenesisParser structure. Miraculously
the problem went away when I initialized it. Valgrind rules!

Now I have a decent set of wildcard tests. One critical set that is missing
still is for field value comparisons. This needs a way for Ftype to do the
comparisons in a general way given the object and a string value. Later.

Another thing pending is to clean up the deallocation of the data part of 
objects. Later.

Checked in stuff as revision 52.

Connected wildcarding between SLI and shell.
Got the SLI drivers to work, some prelimiary unit tests on this. Can't complete
the tests till I have operations working to show messages.
Checked in stuff as revision 53.

Now begun unit tests for biophysics. Did tests for compartments, fixed
bug in compartment messaging in the process.

Checked in as revision 54. Some strange hiccups with SourceForge.

=============================================================================
March 27 2007.
Begun unit tests on HHChannel. Uncovered bug in basic message handling,
that manifested when all children were deleted and then a new one made.
Got to automatic construction and removal of HHGates depending on HHChannel
gating powers. Time to check it in.
Checked in as revision 55.

Valgrind again helped track down a problem, this time with argument usage
between HHChannel and HHGate. I am perhaps asking too much of the gate
function, and it should not be dealing with all this info. I will switch
the numerical integration from the gate back into the HHChannel. This
reduced the number of values being passed around too.

Did major overhaul to accomplish all this. Compiled, back into unit tests.
=============================================================================
March 28 2007

Got HHChannel and HHGates to talk nicely again, got unit tests for reinit
to work.

Checked in as revision 56.

Implemented the action potentials unit test. There is a small nagging
difference between the waveform on MOOSE and the original GENESIS waveforms,
but for now it is pretty clear that the basics work fine.

Checked in as revision 57.

Next: Build the plot object and then it should be possible to run something
close to the squid demo from the earlier version of mus.

Stages, rough order
* Table object to handle output from sim runs.
* Complete biophysics library: Ca concen, Nernst, SynChan, SpikeGen
- Cell reader
- HSolver
- Parallel stuff
- Python pass 1
- Kinetics library
- Dumpfile/kkit read
- Stimfile read capability
- OB sim capability
- SBML read/write
- kinsolvers: ODE, RK5, LSODA, G1, mixed, smoldyn
- Stoichiometry matrix ops: Stoich test
- FLTK graphics.


Compled table, it requires inheritance from interpol, and this is not
working.

=============================================================================
March 29 2007
Table compiles. On to unit tests.
Much effort later, unit tests cleared. Especially ugly because of the zillions
of options in the table class.

Checked in as revision 58.

Working on porting over the old moose squid demo. Numerous problems.
Fixed strSet/strGet for LookupFinfo.
Remaining:
- reset, step need to be activated in GenesisParser
- I need a plot object. The table is nice but does not have a way (yet) to
get values by requesting them.
+ I need to set up a return message from the table that would be used when
	INPUT was the message name. Goes and asks for values from fields.

=============================================================================
March 30 2007

Many updates to Shell and GenesisParser to handle reset, reinit, step, 
showclocks etc. Still does not work with squid demo. For some reason Vm
is not getting scheduled.

A bit of a diversion: Implemented showmsg, with the idea that it would help
me debug the problem with Vm. Fairly involved. Completes old unit tests
but the function itself barfs.
Now fixed. It is a big help. Shows that the Table Vm was indeed connected
up to t0. So why is it not saving data?
Also shows up some oddness in sched: Multiple messages going from
sched/cj to t0.start
Various oddnesses are present. If I repeat a useclock command it croaks.

Well, this is unsatisfactory, but I have made a whole lot of changes and
the old unit tests still pass, so I should check this mess in.
Checked in as revision 59.

=============================================================================
April 1 2007
Jokes aside, still struggling with the test script. I have now added 
further unit tests on the scheduling of different kinds of objects, and
there is no sign of the problematic behaviour I see with the actual script.
Anyway, check in these unit tests.
Checked in as revision 60.

Fixed one of the problem cases in the script.
Now it looks like there is a problem in the SimpleElement::connSrcEnd
function. It was not taking next_ into account but when I try to do this I get
another crash.
Valgrind reports other problems too.

Sorted out problem. The send function uses connSrcEnd to mean only the current
src, not taking into account the next src_ entry if any. I need a separate
function to get the entire list of conns.

Now to implement this alternate way of getting conns. Implemented
connSrcVeryEnd function that many commands should use instead of connSrcEnd.
This seems to have fixed problems with the showmsg command and also with
redoing resets after a simulation is run, and also with repeating the
useclock command. Valgrind is also happier.
The nan problems with the squid demo remain.
Turns out that the table filling was a failure. All entries were zero.
Just got confirmation that the DynamicFinfos for each table assignment are
not cleaned up: all 150 entries for the table were there, but all were zero.
Even when I reassigned them they stayed at zero.
Added another check in LookupFinfo.cpp unit tests, that is cleared. So it
is something in Shell or in GenesisParser.
Fixed: The generalIndex (a void* in DynamicFinfo) was not being set to the
appropriate type for LookupFinfo.
I need now to put in a check that the tables for beta do not get
too close to zero. If they do, then checks will have to be inserted to
avoid divide by zero errors.

For now a small check on the reinit.
And it runs! There is a minor hiccup with the step function using the time
argument as total time, not incremental time. Fixed.
Checked in as revision 61.
Next:
+ enable reuse of DynamicFinfo slots if they don't have messages.
+ Clean up DynamicFinfo: many functions are not used.
+ Get rid of ArrayFinfo.
+ Have freeing of index in DynamicFinfo on destruction.
+ Fix up deallocation of data in elements on destruction.
+ Implement GenesisParser conversion of old message types and table lookups
	so that squid demo can be identically run on genesis and moose.
	Keep this as a target for future sims.
+ Then, move on to Ca concen and stuff.

=============================================================================
April 2 2007.
Lots of cleanup work on DynamicFinfo, got rid of ArrayFinfo.
Checked in as revision 62.

=============================================================================
April 3.
Implemented two freeings: 
- Index of dynamicFinfo on destruction/replacement of the DynamicFinfo
- data_ fields of SimpleElement.

Unfortunately the latter does not seem to work. Clears unit tests but 
valgrind shows no difference in unfreed memory.

Now the destroy is being called, and we run into the double-free problem with
HHGate.
I will need to have two variants of thisFinfo on the Cinfo, one of them
having a flag to prohibit deletion.
I will also have to check for the thisFinfo flag in SimpleElement::delete.

OK, seems to work. Now valgrind finds 1089 /16797 non-freed blocks.
A closer look at the freeing of indices by DynamicFinfo. That too fails
and barfs.
Now that is fixed. But valgrind does not find any fewer non-freed.
Just for the heck of it, I went through and freed Finfos in the vectors
on the Cinfos when destroying the Cinfos. This made it 711 / 16797 blocks.
Some leak is still quite substantial, should track it down. Later.
Should check in but no internet.

Trying now to set up the squid test to run with GENESIS. Mostly there, but
getting nans. Once it works I'll work on parser till it can handle this
script.

=============================================================================

April 5.

Implemented a script for doing the squid demo in GENESIS. It is called
squid_gen.g

Working through the genesis parser backward compatibility to get it to read
this script in. First implemented the message and class conversion.
Currently it handles the table assignments and TABCREATEs for HHChannel.

An issue with the messaging from fields to shared messages such as the
inputRequest of a table or the plot of a graph object. The ValueFinfo
does not seem to recognize it. Turns out it is because the dynamicFinfo
does not know how to handle shared messages as a source. Need to implement.

Checked in as revision 63.

=============================================================================
April 6.
Got the Shared msg from DynamicFinfo to work.
Checked in as revision 64.

Now the only obvious thing remaining for the squid_gen.g to work in MOOSE is
the tab2file.

Did a quick and dirty hack for the tab2file. But there was another issue,
because MOOSE had confusing naming for the inject field and INJECT message.
Sorted that out. Now MOOSE runs the squid_gen.g script too.
Checked in as revision 65.

Implemented CaConc. Unit tests in progress. Done.
Checked in as revision 66.

Implemented Nernst. Unit tests in progress. Done.
Checked in as revision 67.

Implemented SpikeGen. Unit tests done.
Checked in as revision 68.

Working on SynChan. Implemented field part.

=============================================================================
April 7
Implemented most of the rest of SynChan, but its interface requires a rethink
of the channel interface.

Channels in GENESIS and in the current MOOSE design use a separate channel
message and process message. The merit here is that the flow of info is staged;
there are no return messages.

Channels in the earlier MOOSE had no process message. The channel message
triggered their calculations, which went back immediately in a return message.
The merit of this is that it eliminates a lot of extra messaging: speed and
space both. In principle this would also be good for a solver based 
calculation. 
An issue is the handling of CaConc. It may have multiple Ca channel inputs,
so it has to have a Process message to schedule its updates and assignments
of channel values.

For now: stick with the GENESIS compatible design. Fancy stuff is for the
solvers. Later if the return messages from channels look useful we can
change.

Made fixes, but now that I'm into unit tests I find that there is an issue
with the managing of the synapses_ vector. This really needs to be updated
as soon as a message is added _or_ dropped. The clean way to do this is
to equip the DestFinfo (or a derived SynFinfo) with a callback to manage
SynFinfo on the add and drop functions.
For a first pass, trying to set up unit tests for SynChan. Still stuck.

=============================================================================
April 8
For now we'll implement the non-deleteable SynChan. That has passed its unit
tests.
Checked in as revision 69.
That is it for the basic biophysics. Now to get some compatibility fixes in,
leading into readcell capability and the hsolver.

Trying out the original GENESIS squid demo. Of course tons of barfing, but
let's incrementally fix things up.

- Implemented element_list (aka el) command in the parser.
- Tried to implement addtask command as a feed-in to useclock, but this
	cause an assertion error. Tracked it down to the use of the
	form 'CLASS=' in wildcards. There is still some fragility there,
	but fixed for now.
- Cleaned out assorted objects left lying around in the object tree after
	unit tests.

Currently there are 190 errors when I run the original squid demo.
Many of these are simply missing object classes.

Checked in as revision 70.

We now need to implement the copy function. It should be easier and faster
than the old variants, because we use very few pointers. I think the following
should work:
- Copy all SimpleElements without assigning parents etc.
- Duplicate all the DynamicFinfos.
- Recreate their data and copy the values
- Build a map of all the new vs old element ptrs.
- Do a simple copy of the Conns, MsgSrc, MsgDest vectors.
- Go through all new Conns replacing old with new ptrs.
- For all off-tree messages, add a connection to the appropriate src
	and tie up (if in halo mode) to the new tree. Otherwise drop these
	connections (current behaviour.)

=============================================================================
April 9.

All this copy stuff implemented and compiles, not yet tested.
Also implemented the GenesisParser and Shell interface to do it.
Confirmed that it does not yet work. But the old unit tests do work, and enough
changes have been made to require a checkin.
Checked in as revision 71.

Some progress. Various unit tests set up, but the proper copy syntax is not
complete yet.
Much struggling later, turned out that the problem was a really subtle one
where when I used the default constructor T( T ) it bypassed the necessary
Element::Element constructor that set up the ids. Fixed. Added into 
unit tests. Unit tests passed.
Checked in as revision 72.

=============================================================================
11 April 2007
Begun work on cellreader. Trying to compile.

=============================================================================
12 April 2007
OK, compiled in this very skeletal form.
Preliminary variant of readcell works and sets up compartments and their
messages.

Bleargh. Another hour of fighting with subversion/SourceForge. Again SF had
messed up the commit. It is quite a pain to fix things up later. The best
solution seems to be make a backup copy, do an svn revert -R, do an
svn update, and then fix anything still pending.

Now to tackle the compartment parameters.
1. Dimensions. Simple option is to provide xyz coords for compartments. 
This is assumed by a huge range of functions, too.

Did this. The test cell is now the venerable mit.p from my thesis: 286
compartments. Reads in the coords correctly and assigns passive properties
correctly, in at least a couple of the compartments at either end of the cell.

Checked in as revision 74.

=============================================================================
13 April 2007.
Let's try to get the channels in.

Channels are connected in but not set up properly. At least part of the
problem is that MOOSE is not correctly handling all the exotic functions
used to set up channels in standard GENESIS simulations.
Began to implement some of these: setupalpha, setuptau.
Also fixed sundry bugs that crop up as we use the system in new ways.
Checked in as revision 75.

Implemented setupalpha and setuptau. Some table values are now getting
filled.
Checked in as revision 76.

Evidently the shared table code is not working either. The messages that
should tie all the HHGates to the prototype do not form. Instead, at least
for K_mit_usb, the HHGates are duplicated on each channel.


=============================================================================
14 April 2007

first priority: Get the axon to work. Incrementally working through error list.
- TABFILL call now works for channels.
- many aliases are now defined in the .g
- The addalias command is implemented
- The ^ shorthand for recently created elements is implemented.
- Bug in setupAlpha fixed.
- various bugs in the test_axon.g file fixed.

At this point the axon simulation gets set up (using vast amounts of memory,
because all tables are duplicated) but it does not work.
Checked in as revision 77.

Looked at graph curves. Clearly the graphs are not displying correct ss
value.

=============================================================================
15 April 2007
I had not implemented the tweakalpha and tweaktau functions, except as 
dummies. Now I have tested the curves for the channels in GENESIS and
MOOSE, and they match except that GENESIS does use spline smoothing to
set up the curves. There is a glitch in Na_xb.plot in both as well, and I
am tracking it down. It is at -15 mV. The glitch adds exactly the value of the
A curve to the already summed B curve.
The channel set up uses only the setup_tabchan (setupalpha) function.
Fixed the bug.
Fixed the current injection. Now I get action potentials with the 
test_single_compt.g simulation. Hooray!
Also get action potential propagation with the test_axon.g simulation.
Another Hooray!.

Checked in as revision 78.
Looking back at the roadmap from March 28. We now have 3 items under
control. I should add another one, to streamline the use of global objects
like the HHGate. Also a better way of doing function lists would be nice,
to avoid the huge overhead we currently have.

Stages, rough order
* Table object to handle output from sim runs.
* Complete biophysics library: Ca concen, Nernst, SynChan, SpikeGen
* Cell reader
+ HSolver
+ Parallel stuff
+ Python pass 1
+ Kinetics library
- Dumpfile/kkit read
- Stimfile read capability
- OB sim capability
- SBML read/write
- kinsolvers: ODE, RK5, LSODA, G1, mixed, smoldyn
- Stoichiometry matrix ops: Stoich test
- FLTK graphics.

First, a list of fixes that are pending to the messaging system as we
may have to tackle them for the solver and parallel messaging:
- Wasteful implementation for multiple functions in a message using
'next' in the MsgSrc. Problem is that different messages need different ranges.
But the distinct functions of shared messages do not, so they should not be
in different ranges.
- Wasteful pre-allocation of MsgSrc and MsgDest arrays. Can we have them
set up just in time? Can we even set the rare ones on DynamicFinfos?
- Cinfo has a thisFinfo and a noDelFinfo to represent objects where the
	data part should not be deleted. Perhaps this should be a different
	Element class. Option in Create? Better an extField.
+ Copying of prototypes should be aware of cases where the prototype is global.
	Perhaps this concept also applies to parallel prototypes.
	Again, perhaps a distinct Element class.
- Have all SimpleElement operations been put into Element as virtual functions?
- Traversal of messages back to source and through intermediate functions.
	Requires additional info in Finfos and some tricks in the traversal
	functions.
- Naming of functions in the SharedMessages so we can use a named lookup.
- Mapping of SynFinfo to synapse msg# index breaks down on deletion.
Also, some additions that will come up when we handle solvers and parallelism:
- Intercepting set/get calls when an object is solved.
	- Could use a replacement Element* 
	- Could use an entire set of replacement Finfos that forward the
	request to the solver.
	- Could just replace the ThisFinfo to intercept the solved fields
	in a generic way. It could actually handle the whole solver stuff,
	thus avoiding having to tread on any object-local code at all.
- Intercepting messages when an object is solved.
- Providing a dest function based on the calling Ftype in the RespondToAdd
	of the postmaster
- Intercepting all return messages when we attempt to go off-node.
- Intercepting cases where multiple messages go to same node, and having
	the divergence occur on the postmaster of the dest node.
- Handling sporadic messages like action potls, commands, object shifts.
	Need a table like a synapse, that keeps track
	of target node index for the sporadic message, and this plus any
	data is all that goes out. Target node index may have high fan-out.


In the meantime, a small step: Implemented move command.
Checked in as revision 79.

=============================================================================
16 Apr 2007
Small beginning to handling global elements (no copies, only dup of msgs)
Using flag GlobalMarkerFinfo;

=============================================================================
17 Apr 2007
More small progress, implemented most of the functions for global elements
but still need to put them all together in Copy.cpp and to do unit tests
=============================================================================
18 Apr 2007.
The copyGlobal stuff turns out to be quite messy. Now I've set up unit tests
in Copy.cpp, and they are not clearing.

Finally tracked it down. I was appending Conns to the list when doing 
Finfo::incomingConn and outgoingConn functions. Should have instead cleared
out the list. 
Now: unit tests work. test_single_compt.g works. test_axon.g works, and using
showmsg I verified that all the messages point to the library channel gates.
Furthermore the memory use is quite respectable.

I realize that I should do away with the GlobalMarker, DeletionMarker and other
individual Finfos for setting flags. Instead the ExtFieldFinfo is just the
thing to provide flags and anything else. Later.

Some updates from Subhasis, but a lost #include was the only issue with it.

Checked in as revision 83.

=============================================================================
19 Apr 2007
Traversal for messaging. Time to set up virtual messages that represent
logical flow of information within an object. For example, process triggers
VmSrc.

Finfo has incomingConns and outgoingConns functions... fills up provided
vectors. Conn src and dest are current element. Conn index has to help us
use Element::findFinfo( unsigned int connIndex ) to lookup Finfo.

Sporadic messages: typically the commands from one shell to another.
Also action potls.

Note that each postmaster handles a specific remote node.
Here is the partick call sequence.
	0 Post irecv
	1 Tick calls process for outgoing objects.
	2 Post send out id and data together.
	3 Tick calls process for local objects.
	4 Poll for posted irecvs. As they arrive send out contents locally.

Here are the events on the postmaster.
0 Post irecv. Minor problem here because we don't know how much data is to
	come. Typically the main messaging will use lots of space so we can
	be reasonably comfortable with that size buffer. Otherwise we have
	to plan multiple cycles of sending till the whole thing comes.
1 Func arrives because of clock ticks reaching outgoing objects.
	Recvfunc and other type info provided by Ftype of source itself.
	For the sporadic messages:
	- Id of message is found from conn->targetIndex.
	- Id goes into one buffer, data into another. Increment position of
		second buffer by data size. The second buffer is dynamically
		allocated.

2. Post send. This happens frequently if no computation is being run,
	otherwise interleaved with lots of processing.
	- First 2 datums: # of messages and total size.
	- Then the two buffers are appended and sent off.
	- All nodes likewise.
	Repeat till done. This is tricky though.

3. Local process stuff: this does not affect the postmaster other than give the
	data time to flow.

4 Poll for posted irecv. When data arrives, Look up id. Call func. with args.
	For sporadic messages:
	- Check identifier. It points to a msgslot and an ftype to do data
		extraction.
	- Use function provided by ftype to extract correct # of bytes,
		advance pointer, and call correctly typed function on the slot.
	

At initialization time:
Here we need bootstrap the message addition process so that the inter-shell
messages get set up. Master node sends these messages to all other nodes.
Additionally, we may also need to set up fully connected messages between
all shells for handling independent message formation and data transfer
requests.

At message addition time:
	- Identify src and dest nodes
	- Check if same field is a msgsrc to this node.
	- Now we are on src node.
		- query message to check clock tick and if they are sporadic.
		If sporadic:
		- From src node, the respondToAdd function on the postmaster
		must convert ftype into a string to send over. Assemble
		this string, target id, target finfo, and clock tick/sporadic
		flag. Assemble into a message and send this data over as 
		above.
		THIS IS NOW ASYNCHRONOUS. WE DO NOT WAIT FOR AN IMMEDIATE
		RETURN. SEE ABOVE FOR CALL SEQUENCE
		- The recvFunc for this message creation message does checking
		- If all is OK, it builds the message on the far side.
		- It sends back a message with status and any shared message
		requirements.
		THIS COMES BACK WHENEVER THE NEXT TICK OCCURS. PERHAPS MANY
		ARRIVE.
		- The recvFunc for this completes the checking and does the
		setup on the originating side
		- recvFunc may also trigger a flag to tell the scheduler?
		parser? Shell? that the message addition is done, and certain
		operations that were held up can resume.
		This is important if there is a script dependency on completing
		the message. We'll need to establish which functions are 
		permitted in the script. There was a polling function in 
		the earlier version which served this role.

Handling return requests:
	- Identify any messages that are return messages; check if they
		are permitted variants.
		- Ones attached to globals. Here the global should be 
		duplicated on the remote node
		- Non-globals where the message must be instant.
		Here we should flag an error.
		- Non-time-critical returns, e.g., plots. Here we assign
		the return message the same tick as the request by following
		through the dependencies. It will be a timestep off in the
		display, not critical. Could even be corrected post-facto.


.............................................................................

Working on setting up the skeleton of the compilation and the postmasters.

Compiles.
=============================================================================
20 Apr 2007.

Got the initial skeleton code for PostMasters to work, verified using MPI.
Checked in as revision 84.

Set Makefile flags back to non-MPI version to make life easier for other 
developers.
Checked in as revision 85.

Starting on impementation of ParFinfo, though perhaps this should be 
ParFinfoDest. Another set of classes for ParFinfoSrc and ParFinfoShared.

=============================================================================
21 Apr 2007.
Worked out roughly how to handle the actual parallel data transfers.
The approach does not care if the messages are sporadic or scheduled.
It makes one key tradeoff: Puts the target index in each message. This would
be needed anyway for all sporadic messages. At the dest end all it needs is
an array to lookup the target index and return the Ftype* of the attached
message. I could go one indirection less by returning the parIncomingFunc
of the attached message.

The other option is to use a more rigid addressing scheme to get each
datum into its place for scheduled messages. This would require additional
storage for addressing at the sending end, but would use less data for
transfer. Sporadic messages would not benefit. Time about the same.

From benchmarks, bandwidth rises (but sub linearly) with message size. That
means that doubling message size does not quite double message time. There
is also a latency cost, which again does not quite double with message size.
Up to about 256 bytes it is almost flat.
We are talking about 10 usec for 1 K, and 41 usec for 16K. 100 usec for 65K.
For 100 molecules, we go about 10-100x real speed, say 1 msec dt. So we do
a calculation cycle in about 10 to 100 usec. If all of the molecules
diffuse, we need to send 100x12 bytes each way. Here we are about balanced
comm:comput in the worst case, and very comfortable otherwise.
For 5000 molecules we would have a linear scale in comput time, say 500 to 
5000 usec. Communicaton is now 60K bytes, taking ~100 usec.
So the communication is comfortable to interleave, even if we use a faster
solver.

=============================================================================
22 Apr 2007.
An issue here: our sendTo index may not agree with the index given to the
message from postmaster to dest on the target node. The reason is that the
outgoing index is set up so that the recvFuncs are ordered.
Options:
	- Another lookup table for the sendTo index
	- Munge the outgoing function so that all the targets are on the
	same MsgSrc slot and with the same sendTo index as at the originating
	postMaster, but they each have to store their own recvfuncs.

Here is how it works (assuming all messages set up, not worried about sched
at this stage)

- Regular object Send invokes the Ftype1<T>::parOutgoingFunc (or equiv)
	which comes from its own Ftype.
- This calls getParBuf which steps through the parallel outgoing
	buffer and returns the location for value assignment.
	The parOutgoingFunc does typecasting and assignment.
- Outgoing buffer has Nitems, id0, data0, id1, data1...
- All the data gets shifted over to the remote node.
- Postmaster loops through arrived data buffer. id<n> looks up dest Conn
	as well as a templated Ftype::parIncomingFunc.
	VARIANT 1: Regular msging.
	- parIncomingFunc calls the appropriate sendTo<T> function and typecasts
		the data.
		- Advantage: Regular messaging calls for setup.
		- Disadvantage: 
			- Message ordering does not match. Another lookup 
			needed between id and targetIndex. Need to maintain.
			- Terribly slow if we use regular func/msgIndex
			lookup for SendTo.
			- Extra cost of all the MsgSrc entries for different
			dest recvFuncs. We are not using the extra info.
			Unless we do something clever with it for the 
			scatter msgs.
		- Scatter msgs: Extra info in lookup, but it would be a 
		messy iterative call of multiple SendTo.
		- Each message needs:
			Conn: from regular array
			MsgSrc data structures: 3 uints, one RF*, one Ftype*
			Conversion table for lookup of targetIndex from id.
			Further field in conversion to handle scatter.
			Every scattered target needs all but the MsgSrc.
	VARIANT 2: Special msgs. all conns in one big MsgSrc slot, separate 
		recvFunc array for dests.
	- parIncomingFunc is passed the recvFunc, typecasts it, and
		calls it with the Conn.
		- Advantage: Cleaner call sequence. Less indirection.
		- Disadvantage: Unusual messaging. Will need special 
			handling for add/drop
		- Scatter msgs: Flag pointing to range of targets. 
			Rather simple handling of multiple target types.
		- Each message needs:
			Conn index, RF*, Ftype*, scatter::next

	As an alternative, we could just do scatter messages by many 
		explicit connections through the postmaster.
		would be very costly in highly connected networks.
	Or put a fan-out object after the postmaster. Hard to manage.

	VARIANT 3: Use the MsgSrc array as the lookup, with the Slot being 
		given directly from the id (possibly with offset so regular
		messages can live safely below.).
	- parIncomingFunc calls send<T> and typecasts the data
		- Advantage: Almost regular messaging for setup. But some
			redundancy in use of MsgSrc as indices now match ids,
			not unique functions. 
			- Fast.
		- Disadvantage:
			- Memory cost of MsgSrc builds up if lots of unique
			targets.
		- Scatter msgs: Handled cleanly in MsgSrc using existing code.
			Very economical and fast if high scatter.
		- Each message needs:
			Conn: from regular array
			parIncomingFunc array
			MsgSrc for each unique id. Good for high scatter.
			Some cleverness in doing this variant of MsgSrc
			management. Actually the insertConnOnSrc seems to
			do this absolutely painlessly. Only issue is
			MsgSrc size management.

Variant 3 seems neatest, provided I can cleanly deal with the MsgSrc 
management.

.........................................................................
Finally, after much planning, now down to the implementation.

- Implementation
	- Set up the Ftype code
	- Set up ParFinfo
	- Set up add/drop code.
	- Set up ParTick
	- Set up message transfer ops
	- Set up bootstrap

Ftype coding done. This has involved setting up the appropriate functions
for the base Ftype0, Ftype1, Ftype2 and Ftype3. Also several serialization
functions that give us quite a bit of generality including for transferring
vectors and strings.
Stuck on compiling SharedFtype, but it is mostly grinding through the
steps now.

=============================================================================
23 Apr 2007.
Compiled. No new functionality, but the hooks are there for parallel
messaging to be set up.

Checked in as revision 86.


=============================================================================
24 Apr 2007.

Almost all the pieces in place now. Remaining:
+ ParTick
- Clean up postmaster funcs.
- Set up Shell-postmaster messages.

=============================================================================
25 Apr 2007.

Further work on PostMaster.
Implemented ParTick. 
Compilation time.

Checked in as revision 87.

=============================================================================
26 Apr 2007.

Incorporating ParFinfo into the compilation.

Working out how to handle the issues of insufficient information in the
current add and respondToAdd argument lists.

	add( Element* e, Element* destElm, const Finfo* destFinfo )
	respondToAdd( Element* e, Element* src, const Ftype *srcType,
		FuncList& srcFl, FuncList& returnFl,
		unsigned int& destIndex, unsigned int& numDest )

Additional info needed: 
	- id of the target element.
	- Name of the target Finfo.

These are available at the point where the script call happens.
They are lost when we call 'add', because it has to go to the postmaster
(not the dest) and to the 'data' message (not the dest Finfo).
The 'add' function is ubiquitous and we don't want to mess with it.

Solution 1:
	Implement a variant on add for all Finfo classes. Ugh.
Solution 2:
	Provide a wrapper element e, generated on the fly, that
	stores the id and destFinfo name, but provides a handle for
	the originating element to use its regular 'add'.
Solution 3:
	Likewise, but with destFinfo.
Solution 4:
	Generate a regular element on the fly, put some data in it with
	this info. Don't bother clever stuff with OffNodeElement type,
	as all we need here is a handle and SimpleElement will do.


Set up something like solution 2. Still excruciatingly messy. 
Compilation nearly there. Implemented OffNodeElement to handle the extra
info that goes into the off-node messaging. Must remember to delete the
OffNodeElement when done.
Still need to fill in stuff which puts the additional info in the 
OffNodeElement.

=============================================================================
27 Apr 2007.
Successfully compiled. Incorporated OffNodeElement and some updates to
Ftype classes to handle function generation for messaging.

Checked in as revision 88.

Still much to be done, but we should have enough infrastructure to
send information between two nodes if the message setup is hard-coded.
Time to test.
- Confirmed creation of all postmasters.
- Failed trying to connect from object to postmaster.
	Two issues: 
	- Do we use MsgSrc vector for all postmaster messages?
	Yes, because we need unique indexing. If we used that and the 
	MsgDest we'd have two sets of indices.
	- How do we handle its allocation?
	Should be safe just to do a resize or push_back when messages are added.

=============================================================================
28 April 2007.
Still need another fix to the messaging logic. We need a separate Conn from
each MsgSrc in a shared message to the PostMaster. This lets us assign the Conn
id to the destination MsgSrc id, otherwise there is ambiguity.
Then the MsgDest array becomes a mirror of the MsgSrc array on the recieving
PostMaster.

Tryign to compile. Looks like our 'off' element is being retained as a ptr
after it is deleted. I can really add a couple of fields to the postmaster
and accomplish much the same. Let's try that. Check it in first for reference.

Checked in as revision 89 

=============================================================================
29 April 2007.
Now using the PostMaster itself as the holder for the extra info when 
creating off-node messages. Just add a few fields. This lets us eliminate
the ugliness with a Union for Element* and node#, and also the OffNodeElement.

That works, or at least, it passes the limited initial unit tests.
Added a few more tests and it looks like the initial phase of parallel 
messaging is beginning to take shape.

Checked in as revision 90 

As a little side-project, finished implementation of Molecule, implemented
Reaction, compiled, yet to do tests.

=============================================================================
1 May 2007
Flurry of activity: I had checked in the kinetics changes, then Subhasis
checked in lots of stuff for PyMOOSE, and Niraj checked in his solver code
as a branch. Also my regular work laptop died so I will hold on for a while
about doing parallel stuff.
Some design thoughts about parallel stuff, lost with the laptop:
- Give all RecvFuncs an id. There are only about 10-20 per class.
- Pass MsgId, FuncId, data in internode messages.
- Note that if there are distinct target funcs for a given message,
  the FuncIds will differ. No need for further management of 'next' MsgSrcs.
- Don't use MsgSrc on dest node. Use a MsgDest-like structure, indexed
	by MsgId, and holding only the dest Conn ranges. Function is looked
	up by FuncId.
- When making a message, the originating node gets back 
- As before, a dummy RecvFunc is needed by the MsgSrc on the src node.
	We get this by querying the target Finfo for the funcId, and using
	it to find the appropriate dummyFunc (indexed by the same funcId).
	This dummy RecvFunc has the funcId hardcoded in (but I don't know
	how just yet) along with the type conversion stuff.
- In most cases this local query is fine, but we may have messages that
	use DynamicFinfos. Those have to go to the target node to get
	the funcId, and when the report comes back they are redone.



Anyway, I have just work on the enzyme class today. Almost there.

=============================================================================
2 May 2007
Enzyme class completed, compiled, not yet tested.

Checked in as revision 94

=============================================================================
4 May 2007

Implemented unit tests for molecules and reactions. 
Checked in as revision 95

Time to set up solver messaging now that Niraj has implemented the Hsolver.

- We'll intercept all calls to Finfos by having a replacement ThisFinfo.
	The ThisFinfo sports a set of alternate Finfos that are generated
	by the solver. These alternate Finfos are checked first and work like
	this:
	- get: first query the solver for the field value and bung it into
	the field. Finally the 'get' command extracts data from field.
	- set: do the local assignment then put the modified field into the
	solver.
	In both these, the solver provides replacement set/get functions
	- DynamicFinfos: same as set/get.
	An existing DynamicFinfo has its set/get replaced.
	- MsgDest. Here a function is called on the target object. Unless
	I mess with the Conns, there is not much I can do. Instead the 
	solver could extract relevant info from the object using separate
	calls. Issue is that this would require cooperation from the
	object, which violates the idea that solvers should be invisible to
	the object builder.
	Counter point is the synapse. Here the efficiency of the operation
	is pretty critical so we cannot afford extra calls to transfer data
	from object to solver. Somehow the original message should be 
	cleanly redirected to the solver.
	So the only solution, as considered below, is to go through and
	replace all the messages and their funcs.
	- MsgSrc. These can mostly be left alone. They will typically be
	silent, because the Process message is not called. Solver can
	forcibly trigger the remainder. A special case is return messages,
	but those mostly work through the dynamicFinfos.
	
func( const Conn& c, T value ) {
	static_cast< Obj* >( c.data() )->field_ = value;
or
	static_cast< Obj* >( c.data() )->func( value );
	
}

The func is stored on the src. We need to replace it and the target
of the Conn. 

// Note that this only changes the Conn part of the messaging. The
// functions have to be handled separately.
Conn::redirect( Element* newTgt)


// this is called for a field on the object oldE that is going to
// be replaced by newE and newF. srcFl is filled with functions that
// the newE provides to replace those from oldE. destFl comes back with
// functions that the original target wants us to call. Of course, 
// destFl could have been extracted from the original element.
// 
Finfo::redirect( Element* oldE, Element* newE, const Finfo* newF,
			FuncList& srcFl, FuncList& destFl );

Actually we just need to delete the old and add the new.

// Here is is how we would replace a destination func. Suppose we had an
// external ion channel to replace.
// Original:
void Compartment::channelFunc( const Conn& c, double Gk, double Ek)
{
        Element* e = c.targetElement();
        Compartment* compt = static_cast< Compartment* >( e->data() );
        compt->A_ += Gk * Ek;
        compt->B_ += Gk;
}
// Replacement.
void HSolver::comptChannelFunc( const Conn& c, double Gk, double Ek)
{
        Element* e = c.targetElement();
	Hsolver* hs = static_cast< PostMaster* >( e->data() );
	SolveCompt* sc = hs->lookupCompt( c.targetIndex() );
	sc->handleExtChannel( Gk, Ek );
}


Next step: Implement KineticHub and StoichMatrix classes based on the 
old MOOSE versions. The goal is to have something to code toward with the
solver code.

=============================================================================
5 May 2007

Working on Khub.
One level in: we want a ValueWrapperFinfo for solvers for use in the 
modified ThisFinfo of a solved object.

There is a single shared message between solver and ThisFinfo of solved
Element. This handles all the traffic for value set/gets, including any
messages through DynamicFinfos.
- Solver end has LookupFinfos for fields.
- The solver end of the SolverFinfo has an array of 
	- Field finfos. These use the Conn::targetIndex() to look up the
		field in the solver. The assignment call comes to them
		how?
	- MsgDest finfos. These are illustrated above. 
		Note that they behave very differently 
	- Rare MsgSrc finfos. These re
- The zombie end of the SolverThisFinfo has a matching array of regular 
	fields
	- (Q: what to do if the fields themselves are LookupFinfos?)

- We index the fields with an enum.
- We assume all fields are doubles. This also handles bools, ints, etc.
	In the case of other things like strings we need to have a
	separate mechanism. Hopefully rare.
- The ValueWrapperFinfo stores index and the original ValueFinfo from the
	class, and dips into its set and get funcs as needed.
	


=============================================================================
6 May 2007

Setting up infrastructure for kinetic solvers. Ported over most of the stuff
from earlier MOOSE, still need to complete the implementation of KineticHub.
It all compiles but no tests yet.

Checked in as revision 96

To test it: I'll set up a diffusion chain of reactions and load it into
the solver. Check: 
	+ loading, 
	+ creation of Stoich matrix
	+ Computing derivatives.
	- Add enzymes into system.
Then: 
	* Check variable extraction from the diffusion chain.
	* Check parameter assignment in the diffusion chain.
	* Check incorporation of existing messaging in the diffusion chain.
	- Check incorporation of new messages (readouts) in the chain.

Implemented unit tests for loading model into the Stoich class, and 
creation of stoichiometry matrix. Loads of bugs cleaned.

Checked in as revision 97

Implemented unit tests for computing derivatives. Sign fix put in RateTerms.

Checked in as revision 98

=============================================================================
7 May 2007

A little side-tracked as I prepare to set up messages to the KineticHub
preparatory to building the SolveFinfos. 
Worked on SharedFinfos so that they take regular Src and Dest Finfos as 
entries, rather than the TypeFuncPair which had insufficient info.
Fixed many Finfo files as a result.

Checked in as revision 99

Connected up KineticHub, messages succeeded. Now to do the zombie messages.
Hub has: 
For reactions: index for RateTerm, Element* for reacn.
For molecules: Vector of S and Sinit, elist of mols.


First pass at SolveFinfo meant to replace ThisFinfo on the solved elements.
All the required ops are handled skeletally. No compile yet. The
msgSlot stuff is untidy.

Still need to define a counterpart Finfo to the SolveFinfo.

=============================================================================
8 May 2007

Field access now working for zombies. Some initial unit tests done, but
more work required to make it general. The basic approach as discussed,
was to replace the 'ThisFinfo' with a SolveFinfo, and that intercepts
set/get calls for each object. Yet to handle messages or object
creation/destruction.

Checked in as revision 100

Generalized the field access stuff. Now working both for molecule values
and for reaction rates. 

Checked in as revision 101

Remaining:
+ Document it.
- Deal with enzymes
* Deal with existing messages.
- Deal with new message requests
* Deal with existing DynamicFinfos.
- Deal with changing mode of molecule
- Deal with changing mode of enzyme

But the core concepts are in place and working, and the rest is turning
the handle.
=============================================================================
9 May 2007
Cleaned up hub deletion: needed to get rid of SolveFinfos and put back
zombies. Also think about messaging.

=============================================================================
10 May
Slow wok on handling messaging. Most works but message doesn't.
=============================================================================
11 May
still struggling to find timeto work on message redirection. gdb reports
a problem on KineticHub.cpp:698
srcFinfos[ i ]= c.targetElement()->findFinfo( c.targetIndex() );
Something funny happens when the finfo is returned from findFinfo.
Valgrind it. No obvious mem issue found.

=============================================================================
13 May 2007
Finally got the message redirection stuff to work. 

Checked in as revision 102

=============================================================================
14 May 2007
Looks like for the DynamicFinfo all we need is to replace the set and get
funcs from the altered Finfos.
=============================================================================
15 May 2007
A closer look shows that it is not so simple.

DynamicFinfo --> dest: Here the DynamicFinfo must call a dest function
with a value it looks up using an access func. Here in principle we could
replace the 'get' access func.

DynamicFinfo <--> dest : Here we have the DynamicFinfo receive a trigger
from the dest, do a lookup, and call the dest recvFunc with its looked up 
value. Here again we could replace the 'get' accessFunc. The trigFunc is 
independent of access funcs and could stay.

DynamicFinfo <-- dest: Here we have to give the dest the accessFunc for the
origFinfo encapsulated by the DynamicFinfo. Have to redo the message.

A clean and comprehensive way to do all this is just to rebuild the dynamic
finfo by replacing all its messages. We already have a powerful func for 
doing this in the form of redirectDestMessages.

We might save a little setup time in the first two cases if we replace
the access funcs. But we would still need to do the redirect, so it would
be a messier coding solution.

OK, implemented the solution where we rebuild the DynamicFinfo completely.
Now to test it.

A bit stuck. The message claims to be formed but the value it gets is 
the unzombified value from the object. Redirection does not seem to be
happening, but the redirection function is called. It uses a very odd looking
Conn in the redirection.
More fundamental issue with getting values from zombie. Works at first,
but not later.
Ooops, lots of errors. I was doing an assert on dret=<num>
Should be ==.

Now that it is fixed, I'm still stuck at the same place. The second time I
try to do zombie field access I fail.

OK, I see it. In the second attempt at field acces, we are going through the 
DynamicFinfo because a message has been set up. This DynamicFinfo is confused.


=============================================================================
16 May 2007

Fixed up the implementation via DynamicFinfo. It had been looking up itself
instead of the Finfo provided by the solver. Now it works, passes unit tests.

Did a bit more work on the solver documentation.

Checked in as revision 103

Also added unit test to show that new DynamicFinfos, added after solver is
in place, correctly forward requests to the solver.
Checked in as revision 104

=============================================================================
17 May 2007
A little work setting up Enzyme unit tests preparatory to tying it to
the solver.
=============================================================================
18 May 2007
Partial implementation of Enzyme unit tests: Explicit enz. Barfs at the stoich
unit tests in TestKinetics.cpp.

Completed Enzyme unit tests for Implicit enz also, as well as switching
between explicit and implicit. Fixed bug in Stoich unit tests.

In the meantime several updates seem to have been checked in by Subhasis to
deal with the python wrappers.
Checked in as revision 108

=============================================================================
19 May 2007
Made logo.
=============================================================================
20 May 2007
Implementing SimDump feature. Compiles, not yet folded into operations of
Shell.
Checked in as revision 109

=============================================================================
21 May 2007
Cleaning up incorporation of SimDump into GenesisParser and Shell.
=============================================================================
24 May 2007
SimDump compiled.
Cleaned up really nasty parser bug for non-existent include files. Turned
out to be a double free.
Headache getting simObjDump count to match with the actual simUndump call.
Turned out to be a problem handling blank strings. Need a different separator.

OK, an intermediate fix: Earlier I was not including blank strings as valid
arguments. Now I am. Now it loads in and assigns values for molecules and enz,
and also looks like it sets up messages correctly. Time to check it in.
Checked in as revision 110

Working on separator. Now it handles arguments in quotes even if they
have separators in them.

Next issue: Handling the plot messages.
That done.
Next issue: foreach is not handled properly.
Also: Graphs do not save values. All values are nan.

=============================================================================
25 May 2007
Finally got a kkit model to load and run. Now to fix up the foreach and so
on for setting up the plots automatically so I can run any kkit model.

Fixed up the set command to set fields on multiple objects.
Successfully loaded up and ran all the simple models and the Kholodenko 
oscillatory MAPK model.  Plotting is still ugly.  Foreach remains to fix.

Checked in as revision 111

First pass on the Kintegrator. Trying to compile a framework.

Well, surprisingly the unit tests suggest it works first off, at least
with the Forward Euler default integration scheme. I need a testable
model to run here. Maybe something diffusive.
Tried out a 100-compt model with slightly faster diffusion. Still need
to test the decay curve against an exponential.

=============================================================================
26 May 2007
Checked in as revision 112

Trying now to examine entire set. This involved converting the free-floating
end molecule to a buffered one. This reveals all sorts of problems with
the Stoich and other parts of the solver.

Need to write out the solution scheme and redo.

Done. It turns out to be a simple matter of excluding the rows for 
buffered molecules. At some later stage this would be a good way to toggle
buffering. I have two buffered molecules now in the model, and it all
works. Also implemented a nice simple unit test for diffusion.

Now starting out on the GSL implementation.

=============================================================================
28 May 2007
Finally getting close to the GSL stuff. Some retrofitting needed on
Stoich.cpp, compiled it without the GSL stuff to make sure the old code still
works. Yes. Passes unit tests. Now on to GSL portion.

Also looked at CVODE. Fortunately it has the same functional form as GSL
for its core stepper function, which Stoich provides. CVODE also seems to have
parallel solver capabilities, something to keep in mind.

OK, GSL integrator works. Haven't really stretched it yet nor analyzed its
stepping patterns, but it passes the basic unit tests for 21-compartment
diffusion using rk5.
For the purposes of the checkin, I have compiled it without the GSL flags,
so as to preserve the plain vanilla version with minimal library dependencies.

Checked in as revision 114

=============================================================================
29 May 2007
Running through the various routines. Quite disappointing. Turns out that 
rk4 is often a problem due to excessively small dt. It seems to be invoked
within gear2 as well. Then, rk8pd gives too big an error. Surprisingly,
rk5 is nice and quick. Perhaps I need to relax the relative accuracy
criterion for the GSL...

Gone through the whole set:

rk2.Err=	3.24919e-07,	accRequest= 1e-06,	Copy:Call=   2455:4799
rk4.Err=	7.16957e-09,	accRequest= 0.0001,	Copy:Call=  10621:31790
rk5.Err=	5.49466e-06,	accRequest= 1e-06,	Copy:Call=   1131:3808
rkck.Err=	3.4423e-06,	accRequest= 1e-08,	Copy:Call=   2757:9605
rk8pd.Err=	7.513e-05,	accRequest= 1e-07,	Copy:Call=   2337:16310
rk2imp.Err=	3.71797e-05,	accRequest= 1e-06,	Copy:Call=   8513:25481
rk4imp.Err=	0.000347163,	accRequest= 0.0001,	Copy:Call= 105781:110877
gear1.Err=	3.78904e-05,	accRequest= 1e-06,	Copy:Call=  14638:73190
gear2.Err=	0.00025797,	accRequest= 0.0002,	Copy:Call=  75823:83406

Clearly, RK5 handles this kind of problem the best. RK2 is surprisingly good
too. RK2imp takes honours among the implicit methods. RK4 is surprisingly
bad throughout. A bit of optimization in the SparseMatrix will help
memory a lot and possibly speed too.

Anyway, let's check this in before fooling around with SparseMatrix 
optimizations.

Checked in as revision 115.

Now saved again, with compile flags set not to use GSL.
Checked in as revision 116.

Tried compiling with O3. Unit tests fail in a strGet call. When I patch around
that with a -g compile for the basecode, it compiles. After a few fixes 
in the unit tests it clears everything. I had intended to time the above
numerical integration calculations to compare with a proposed rewrite of
SparseMatrix, but the thing is too fast now for hand timing. Put in a
gettimeofday call and it comes to about 1.62 sec (ave of N=3).

Note that there are loads of spurious warnings with O3 about uninitialized
variables, even though they are actually OK.

Much messing around with SparseMatrix reimplementation. Now it works.
Recompiled with the O3, and ran it... Hooray, nearly 2x speedup:
0.88 sec (ave of N=3).

Some more cleaning up of SparseMatrix pending, but good to check it in now.
Checked in as revision 117.

Rearranged Makefiles to keep it easy for other users to compile without
GSL or optimization.
Checked in as revision 118.

Various levels of cleanup needed:
	- Simundump should work for bigger and harder models
	- Handle tables in kinetic sims
	- Automatic solver creation for simdump files.
	- Benchmark against old moose, esp for rk5.

Next major steps:
	- Parallelization


=============================================================================
31 May 2007.

Looking at overall structure for parallelization.
We have two kinds of data transfer:
Synchronous: Every time step, exactly same data, same sequence.
	Examples: Diffusion messages. Dendro-dendritic info.
	Requires: 
		- Call sequence matches conn sequence on remote node
		- MsgDest vector entry for each func.
		- Func/MsgDestIndex vector entry for each func
			( We can't merge them because of bidirectional msgs)
		- Some identification from ParTicks to the set of msgs to call.
		- Individual msg entries for multiple targets: single fan-out.
	Features: 
		- Minimal data transfer
		- Fast at the node level because func calls all grouped
Asynchronous: Random times, random orders.
	Examples: Synaptic info. Cross-node Shell commands.
	Requires:
		- MsgDest vector (also needed for bidirectionality)
		- Global Func management
		- Func id + msg index to be tranferred for each hunk of data.
	Features:
		- Arbitrary ordering, easy setup
		- Multiple fan-out on remote node.

Plan: Start with asynch. See how it works and design synch as needed.


Started. Implemented FunctionData class, got it set up to record creation
of functions used in ValueFinfo and DestFinfo.
We will have problems for the old-style (deprecated) sharedFinfo usage of
functions as those do not get initialized into the FunctionData.
Turns out that there are currently about 150 functions used.
I'll incrementally clean up.

=============================================================================
