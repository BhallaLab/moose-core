/**********************************************************************
** This program is part of 'MOOSE', the
** Messaging Object Oriented Simulation Environment,
** also known as GENESIS 3 base code.
**           copyright (C) 2003-2005 Upinder S. Bhalla. and NCBS
** It is made available under the terms of the
** GNU Lesser General Public License version 2.1
** See the file COPYING.LIB for the full notice.
**********************************************************************/

/**
 * \mainpage MOOSE Code documentation: Generated by Doxygen.
 * 
 * \section intro_sec Introduction
 * MOOSE is the Multiscale Object Oriented Simulation Environment.
 * This Doxygen-generated set of pages documents the source code of
 * MOOSE.
 *
 */

#include <iostream>
#include <basecode/header.h>
#include <basecode/moose.h>
#include <element/Neutral.h>
#include <basecode/IdManager.h>
#include <utility/utility.h>
#include "shell/Shell.h"

#ifdef USE_READLINE
#include <readline/readline.h>
#include <readline/history.h>
#endif //USE_READLINE

// Defined in init.cpp
extern unsigned int init( int& argc, char**& argv );
extern void terminateMPI( unsigned int myNode );
extern void pollPostmaster();
extern void setupDefaultSchedule(Element* t0, Element* t1, Element* cj);

#ifdef DO_UNIT_TESTS
	extern void testBasecode();
	extern void testNeutral();
	extern void testSparseMatrix();
	extern void testShell();
	extern void testInterpol();
	extern void testTable();
	extern void testWildcard();
	extern void testSched();
	extern void testSchedProcess();
	extern void testBiophysics();
	extern void testHSolve();
	extern void testKinetics();
	extern void testKsolve();
//	extern void testAverage();
	extern void testParMsgOnSingleNode();
	extern void testPostMaster();
#endif

#ifdef USE_GENESIS_PARSER
	extern Element* makeGenesisParser( );
//	extern void nonblock( int state );
	extern bool nonBlockingGetLine( string& s );
#endif

/**
 * This dummy function is called after all unit tests are done.
 * Useful in debugging, when you don't want your breakpoint to wake up during
 * unit tests.
 * 
 * Use like this:
 * 		- Set breakpoint in this function
 * 		- When control reaches this function, set further breakpoints of interest.
 * 		  They will now get activated only during running of the main program.
 */
void breakMain() { ; }

int main(int argc, char** argv)
{
	init( argc, argv );
	
	unsigned int myNode = Shell::myNode();
	
#ifdef DO_UNIT_TESTS
	if ( myNode == 0 )
	{
		/*
		*/
		testBasecode();
		testNeutral();
		testSparseMatrix();
		testShell();
		testWildcard();
		testInterpol();
		testTable();
		testSched();
		testSchedProcess();
		testBiophysics();
		testHSolve();
		testKinetics();
		testKsolve();
//		testAverage();
		testParMsgOnSingleNode();
	}
	// This is a special unit test: it MUST run on all nodes.
	testPostMaster(); // This is a dummy if no postMaster exists.
#endif


#ifdef USE_GENESIS_PARSER
	Element* sli = makeGenesisParser();
	assert( sli != 0 );
	breakMain();

	if ( myNode == 0 ) {
		string line = "";
		vector<string> scriptArgs = ArgParser::getScriptArgs();
		
		if ( scriptArgs.size() > 0 )
		{
			/*
			 * The genesis parser does not like back-slashes in the path.
			 * Luckily, forward-slashes seem to work on Windows (tested on XP).
			 * Here we replace back-slashes with forward-slashes in the path.
			 */
			string& path = scriptArgs[ 0 ];
			size_t pos;
			while ( ( pos = path.find_first_of( "\\" ) ) != string::npos )
				path.replace( pos, 1, "/" );
			
			line = "include";
			for ( unsigned int i = 0; i < scriptArgs.size(); ++i )
			{
				line = line + " " + scriptArgs[i];
			}
			line.push_back('\n');
		}

		// Need to do this before the first script is loaded, but
		// after the unit test for the parser.
		Id cj("/sched/cj");
		Id t0("/sched/cj/t0");
		Id t1("/sched/cj/t1");
		
		// Doesn't do much. Just sets dt and stage, and cals reset.
		if ( Shell::numNodes() == 1 )
			setupDefaultSchedule( t0(), t1(), cj() );

		const Finfo* parseFinfo = sli->findFinfo( "parse" );
		assert ( parseFinfo != 0 );

		set< string >( sli, parseFinfo, line );
		set< string >( sli, parseFinfo, "\n" );

		/**
		 * Here is the key infinite loop for getting terminal input,
		 * parsing it, polling postmaster, managing GUI and other 
		 * good things.
		 */
		string s = "";
		unsigned int lineNum = 0;
		#ifndef USE_READLINE
		cout << "moose #" << lineNum << " > " << flush;
		#endif //n USE_READLINE
		while( Shell::running() ) {
			#ifdef USE_READLINE
			char cname[25];
			sprintf(cname, "moose #%d > ", lineNum);
			char * foo  = readline(cname);
                        if (NULL == foo) // EOF (Ctrl-D) in stdin
                        {
                            // rather than exiting abruptly, take it
                            // as quit command hoping that all
                            // cleanups will be done by the shell
                            // before quitting
                            s = "quit"; 
                        }
                        else 
                        {
                            s = string (foo);
                            free( foo );
                        }
                        
			set< string >( sli, parseFinfo, s );
			if ( s.find_first_not_of( " \t\n" ) != s.npos ){
				lineNum++;
				add_history( s.c_str() );
			}
			s = "";
			#else
			if ( nonBlockingGetLine( s ) ) {
				set< string >( sli, parseFinfo, s );
				if ( s.find_first_not_of( " \t\n" ) != s.npos )
					lineNum++;
				s = "";
				cout << "moose #" << lineNum << " > " << flush;
			}
			#endif //USE_READLINE
			pollPostmaster();
			
			// gui stuff here maybe.
		}
	} else { // All but master node.
		while( Shell::running() ) {
			pollPostmaster();
		}
	}
#endif
	terminateMPI( myNode );
	if ( myNode == 0 )
		cout << ".. bye\n" << flush;
}
